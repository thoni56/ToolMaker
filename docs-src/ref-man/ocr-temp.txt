ToolMaker
Reference Manual
Version 2.0
==================================================
Part III
ScannerMaker
Reference Manual
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 162 -- ScannerMaker Reference Manual

4   THE SCANNERMAKER COMMAND
The invocation of the scanner generator is performed by the following program call

smk [-help] [<options> ...] <file>

The special option -help gives a short help of available options and their meaning.

The default extension on the ScannerMaker description file is smk which is added if not explicitly stated.

4.1 Parameters

The command takes only one argument, the name of a description file. The description file contains a description of the scanner to be made using a formal language as described in The ScannerMaker Description File on page 138. The argument may appear anywhere on the command line except between any option and its argument.

4.2 Options

One or more options may be specified on the command line overriding any specified options in the options section in the description file. The only options which can not be specified in the options section are
option
-help
-voc <file> -smt <file> -sml <file>

All other options have the same names as in the options section. For a detailed description on how to specify options on the command line see Command Line Option Format in the ToolMaker System Description, page 40.

The following options have no corresponding directive in the options section of the description file and are therefore thoroughly described:

-help

This special option produce a verbose listing of the usage format of the command. Each argument and option is given a short explanation.

-voc <file>

The vocabulary used is read from the <f i l e> as specified as argument to this option. By default the vocabulary is read from a file with the same base name as the description file but with extension voc.

@PAGE 163 -- ScannerMaker Reference Manual

-sml <file>

The specified file is used as list file. By default the name of the list file is the same as the description file but with extension.sml. Note that this option does not produce any list file if no list directives are used.

-smt <file>

The specified file is used as the table file. By default the name of the table file is the same as the description file but with extension smt. Note that this option does not imply that the table file should be saved after source code generation, it simply indicates its name (see also The Maker in the ToolMaker System Description, page 25 for a description of the intelligent generation strategy and File Descriptions on page 138).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 164 -- ScannerMaker Reference Manual

5   SCANNER RUN-TIME USAGE

5.1 Principles of Operation

To use a ScannerMaker generated scanner the following step should be performed:

* create a new scanner context (see below)
* initialise the reading from the input stream (e.g. open the file and attach it to the context)
* call sniScan until end of input

During each call to the scanner the appropriate semantic action will automatically be performed (see Semantic Actions on page 158) in which various of the features of the generated scanner can be used. It is also possible to create additional contexts, using the function smScNew, and switch scanner and vocabulary during the scanning process.


5.1.1   Type: smScContext and smScContextItem

TYPE smScContext IS POINTER TO smScContextItem

TYPE smScContextItem IS STRUCTURE smSize    : INTEGER
smText  : STRING
smLength    INTEGER smBufferOverflow: INTEGER SmPOSition: INTEGER
smLine  : INTEGER smColumn : INTEGER smNextPosition: INTEGER smNextLine: INTEGER smNextColumn: INTEGR smScanner : smScScanner

declarations from the context section END STRUCTURE
A context is the main object in the generated scanner. Almost all functions operate on that object. A context consist of a buffer, source position, scanner, and user defined variables.
In object oriented languages this type is declared as a class named smScContext with the structure components above as public members.
Note: All predefined variables starts with the characters sm and can not be changed. This is not the scanner prefix used as a prefix for the exported functions and the context data type.

@PAGE 165 -- ScannerMaker Reference Manual

The Context Buffer
smSize  : INTEGER

The context buffer is divided into two parts, the token and the input stream, where the input stream always follows the token. Initially the token length is zero and when end of text is found the input stream has a length of zero. The size of the context buffer can be found in the smSize field. Initially the length of the context buffer is zero.

smText  STRING smLength : INTEGER

The variable smText holds the last scanned token and smLength is the length of the token. The characters in smText may be altered freely but if any altered characters are skipped back into the input stream the source position calculation will be wrong if any newline characters was altered or inserted.

Great care should be taken not to alter any characters after the last character in the token permanently. It is alright to alter the character while in a semantic action and then restoring the old character before leaving the semantic action or calling the scanner recursively. For example, to convert a token representing an integer into an integer, the unix standard function atoi could be used. However, this function requires that the string representation is null terminated but ScannerMaker does not null terminate a token string so this must be done explicitly.

Integer = [0-9]+
unsigned char *remind;
remind = smThis->smText[smThis->smLength]; smThis->smText[smThis->smLength] = 0; smToken->ival = atoi(smThis->smText); smThis->smText[smThis->smLength] = remind;
It is very important to restore the character over-written by the null character as in the example above or else the next token would start with a null character.
smBufferOverflow: INTEGER

If the scanning of a token exceeds the maximum token length or the reallocation to a larger buffer fails, characters in the buffer will be skipped. The number of characters saved equals to the minimum length of the token and the only characters saved are the last one in the buffer. The variable smBuf ferover flow holds the number of characters which is skipped. The source position will still however reference the true beginning of the character but the smLength will not include any skipped characters. Thus the true length of the token is the sum of smBufferOverflow and smLength.

If no overflow occurs smBuf ferOverf low will be zero.

@PAGE 166 -- ScannerMaker Reference Manual

Changing the context can be necessary when changing from one source of input to another. This can be achieved by simply replacing the current context variable with a new (created using the smNew function). To be able to restore the previous context the context buffers should be linked or stacked, which is the responsibility of the user


The change of a context should preferably be performed outside the actual generated scanner, e.g. in a function enclosing the smScan function, which recognises and handles situations when this is necessary.


Note: The prehook, action and posthook section and the semantic actions are all called using the same context (the one passed to smScan).
Source Position
smPosition: INTEGER smLine  : INTEGER
smColumn : INTEGER
The source position is only calculated if the appropriate source position directive is given in the source position section. The line number and column number start from one and the position from zero. The position is the number of characters read in this context before the token. The source position will always be correct with one exception. If altered characters are returned to the input stream by using smScSkip instead of smScModi fy and any newline is altered to a character other than the newline character or if a character is altered to a newline, then the source position will be computed incorrectly. However, if the number of newlines are the same the source position will be correct after the next newline following the altered characters. The suggestion is not to return any altered character with the smScSkip function.


When smScModi fy is used to return altered characters to the input stream any token found containing altered characters will have the source position of the token following the token which altered the input stream. For example
'hello' = 'hello' %% smScModify(smThis,"theis",-5) %%; 'the' _ 'the' %% ... %%;
'is'    'is'    % ... %%;
when the token 'hello' is found, the token is altered to 'theis'. If the source position of 'hello' was line one and column five, then the next token should be found at line one and column ten. This is the line number which is reported by 'the', 'is', and the token following 'is'.
smNextPosition: INTEGER smNextLine  : INTEGER
smNextColumn    INTEGER
The next positions gives the next token's position. That is, the token following the current one.

@PAGE 167 -- ScannerMaker Reference Manual

Scanner
smScanner: smScScanner

Which scanner a context should use is determined by the value of the smScanner variable. Available scanners are determined by the description file defining the scanners. An enumeration type is defined containing an enumeration literal for each scanner. The name of the enumeration literal is the scanner prefix concatenated by the vocabulary name and scanner name surrounded by underscores and finally the characters 'Scanner' as a suffix. For example, if the scanners main and comment are defined the following enumeration type is defined (if 'c' is the target language):

typedef enum smScScanner {
* MAIN-MAIN-Scanner= 0,
sm_MAIN COMMENT Scanner= 1,
sm_SET MAIN Scanner = 2 } smScScanner;

By simply changing the value of the smS canner field in the context variable a new scanner is entered. The variable can be changed any time and the effect is immediate. For example, it is possible to change scanner in a semantic action and then continue scanning using the newly selected scanner.

For each vocabulary there is also an enumeration type defined containing enumeration literals for all tokens defined in that vocabulary. The name of the enumeration type is smfollowed by the vocabulary name enclosed by underscores and followed by the characters 'ScToken'. Each enumeration literal is named sm followed by underscore, vocabulary name, underscore, token name or external token code for a string token, underscore, and Token. For example, if 'c' is the target language:
typedef enum sm main ScToken { am-MAIN-UNKNOWN-Token = 0,
* MAIN ENDOFTEXT Token = 1,
* MAIN_2 Token = 2,
* MAIN_INTEGER Token = 3,
} sm main_ScToken;


5.2 Run Time Interface

The run time interface consist of a number of functions. All functions except smScScrScanner, smScScrToken, and smScScrRule operates on a context. In a non-object oriented language the context is always given as the first argument. In an object oriented language these functions are member functions to the smScContext class and messages are sent to a context object.

5.2.1   Function: smScan

code = smScan(smThis,smToken)

@PAGE 168 -- ScannerMaker Reference Manual

smThis  : IN smScContext
smToken IN OUT %%(tokenType) returns INTEGER

This function scans a new token. If successful, the token code is returned and the token structure or record is assigned the token code and source position, if used. If the reader, as defined in the reader section, returns a negative value this is immediately propagated as the return value of the smScan and the scanning is aborted.

5.2.2   Function: smScNew

context = smScNew(smScanner)
smScanner: IN smScScanner returns smScContext

This function is a so called constructor. It constructs a new context with the specified smScanner.

5.2.3   Function: smScDelete

smScDelete(smThis)
smThis  : IN smScContext

This function is a so called destructor. It destroys a context and its buffer. 5.2.4    Function: smScSkip

length = smScSkip(smThis,smLength)
smThis  IN SmContext
smLength    IN INTEGER returns INTEGER

This function changes the token by either replacing characters from the end of the token to the input stream, or by extending it by reading characters from the input stream. The number of characters replaced or read are given by the value of smLength. A negative value replaces characters and a positive value reads characters. The actual number of characters replaced or read are returned. For example,

smScSkip(smThis,-3);

returns the three last characters of the token to the beginning of the input stream. The length of the token will be three characters shorter. However, if it has a length of less than three characters, for example one character, only that many characters will be returned. If the reader, as defined in the reader section, needs to be called to fetch further characters from the input stream and it returns a negative value, this is immediately propagated as the return value of smScSkip and the skipping is terminated.

@PAGE 169 -- ScannerMaker Reference Manual

5.2.5   Function: smScModify

length = smScModify(smThis,smBuffer,smLength)

smThis  : IN smScContext smBuffer : IN STRING
smLength    IN INTEGER returns INTEGER
This function modifies the token or input stream in the same way as smScSkip but all affected characters (replaced to the input stream or appended to the token) are modified by characters from the specified buffer. For example
smScModify(smThis,"123",3);
appends the token with three characters from the input stream and modifies them to be "123". That is, the token now ends with "123".
smScModify(smThis,"123",-3);
returns the three last characters of the token to the beginning of the input stream and replaces them with "123". If the reader, as defined in the reader section, returns a negative value this is immediately propagated as the return value of smScModi fy and the modification is terminated.

5.2.6   Function: smScCopy

length = smScCopy(srThis,smBUffer,smFrom,smTo)

smThis  : IN smScContext
smBuffer    OUT STRING
smFrom  : IN INTEGER
smTo    : IN INTEGER returns INTEGER
Copy the token into the buffer specified. The token's characters are not mapped. The copy starts to copy characters from the smFrom position up to but not including the smTo position from the current token. The number of characters copied is returned. For example, to copy all characters use:
smScCopy(smThis,buffer,0,smThis->smLength);


5.2.7   Function: smScMapCopy

length = smScMapCopy(smThis,smBuffer,smFrom,smTo)
smThis  : IN smScContext
smBuffer    OUT STRING
smFrom  : IN INTEGER
smTO    : IN INTEGER returns INTEGER
Copy the token into the buffer specified in the function call. The characters of the token are mapped using the specified character map as specified in the map section. The copy starts to copy characters from the smFrom position up

@PAGE 170 -- ScannerMaker Reference Manual

to but not including the smTo position from the current token. The number of characters copied is returned.

5.2.8   Function: smScScrScanner

void smScScrScanner(smScanner,smOnOff)
smScanner   IN smScScanner
smOnOff : IN BOOLEAN

This function turns on or off checking of screened tokens for the specified scanner. If the scanner has screened tokens these are not recognized if screening is turned off.

5.2.9   Function: smScScrToken

void smScScrToken(smScanner,smToken,smOnOff)
smScanner   IN smScScanner
smToken IN sm vocabularyname_ScToken
smOnOff IN BOOLEAN

This function turns on or off checking of screened tokens for the specified token. If the token has screened tokens these are not recognized if screening is turned off.

5.2.10  Function: smScScrRule

void smScScrRule(smScanner,smToken,smOnOff)
smScanner   IN smScScanner
smToken IN sm_vocabularyname_ScToken
smOnOff IN BOOLEAN

This function turns on or off checking of the specified token. If the token is a screened token it is not recognized if screening is turned off.

5.3 Recursive Calls and Continued Scanning

There are two ways in which scanning may proceed directly from inside a semantic action without actually returning from the current call. Either the scanner can be called recursively or the scanning may be continued.

5.3.1   Recursive Calls

Inside any action or target language code section it is possible to call the scanner recursively. However smToken should never be passed to any called scanner because it will over-write the current token code. Also note that the variable smToken is not defined in the code section.

The current token is reset by a recursive call. That is, after a recursive call the
smText and smLength will refer to the last scanner token. For example

@PAGE 171 -- ScannerMaker Reference Manual

INCLUDE = '#include'
TmToken myToken;
/* #include "astring" */ if(smScan(smThis,&myToken)==2){
/* open file and create a new context
} else (
error("Illegal include statement");
}
After calling smScan () the string ' #include' which could be found in smText is replaced by the next token, in this case hopefully a string.

5.3.2   Continued Scanning


It is also possible to continue scanning after a token is found by setting the external code to smContinueToken or returning smContinueToken in the action section or the semantic actions. The current token will be appended with the new token found after a continued scanning is made. The new token will be returned.That is, in the example below the complete string will be found in the last semantic action.


For example
STRING = "" P "I '"' / '",
%% return smContinueToken; %%;
STRING =
%% ...
or
STRING = ' ' [-I ' ' / , ,
%% smCode=smContinueToken; %%; STRING = "" P"] ""
%% ... %%;
Continued scanning can only be used in the action section and inside semantic actions.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 172 -- ScannerMaker Reference Manual

A   THE PL/O EXAMPLE
This example is a part of the pl/0 example used throughout the ToolMaker documentation. The ToolMaker System Description contains a detailed walkthrough of the relevant parts of the example. This appendix contains the files relevant for ScannerMaker.
A.1 plO.smk -- The ScannerMaker Description File ------------------------------------------------------
-- p10.smk  Date: 1993-06-24/toolmake -- p10 -- ScannerMaker description file

-------------------------------------------------------- Created:   1993-04-27/reibert@roo -- Generated: 1993-06-24 12:42:46/toolmake v2,r0,c12 ------------------------------------------------------

%%OPTIONS Verbose;
%%IMPORT
#include <stdio.h>

#include "plOList.h" #include "plOScan.h"

%%EXPORT

extern void scan(TmToken *token);
extern int plOScanEnter(char *fileName); extern void plOScanTerminate(void);

%%CONTEXT
char *fileName; int fd;
plOScContext previous; int fileNo;

%%READER
return read(smThis->fd, (char *)smBuffer, smLength);
%%DECLARATIONS
static plOScContext lexContext;
static int fileNo = 0;/* Count included files */ int plOScanEnter(
char fnm[]/* IN - Name of file to open
plOScContext tmp; ){
tmp = p10ScNew(p10 MAIN MAIN-Scanner); if (fnm == NULL)
tmp->fd = 0;
else if ((tmp->fd = open(fnm,0)) < 0)
{
p10ScDelete(tmp);
return 0;

@PAGE 173 -- ScannerMaker Reference Manual

} else {
tmp->fileName = fnm; tmp->fileNo = fileNo++; tmp->previous = lexContext; lexContext = tmp;

return 1;
/*

plOscanExit()

Terminate and delete the current lexical context. static void plOScanExit(void) plOScContext old;

close(lexContext->fd);
old = lexContext;
lexContext = lexContext->previous; plOScDelete(old);
1*

plOScanTerminate()

Make sure all contexts are terminated (e.g. in case of parser abort).
void plOScanTerminate(void)

while (lexContext)

plOScanExit();
/*

scan()

Outer scanner called from the parser. Handles switching of contexts.
*/
void scan(
TmToken *token ){
plOScan(lexContext, token);

switch (token->code) {

case p10 MAIN_ INCLUDE Token:
if (plOScanEnter(token->stringValue)) { TmSrcp srcp, start;

srcp = token->srcp;
srcp.line++;/* Make include start on next line srcp.col = 1;
*/

@PAGE 174 -- ScannerMaker Reference Manual

start.file = fileNo; start.line = 0;
plOLiEnter(&srcp, &start, token->stringvalue); } else {
plOLog(&token->srcp, 199, sevFAT,

token->stringValue);

/* Get next token and return instead of the INCLUDE */ pl0Scan(lexContext, token); break;

case p10 MAIN ENDOFTEXT Token: plOScanExit();
if (lexContext)/* If still more input get a token plOScan(lexContext, token); break;
}

%%POSTHOOK

smToken->srcp.file = smThis->fileNo; %%DEFINITIONS

Letter = [A-Za-z\xCO-\xD6\xD8-\xF6\xF8-\xFF]; Digit = [0-9];
White = [ \t\n];
%%VOCABULARY main %%SCANNER main %%RULES
NUMBER = Digit+
%%
plOScCopy(smThis,
(unsigned char *)smToken->stringValue, 0,
smThis->smLength); smToken->stringValue[smThis->smLength] = 0; smToken->integerValue=atoi(smToken->stringValue);


IDENTIFIER = Letter ('_ ? Letter !  ? Digit)*

plOScCopy(smThis,
(unsigned char *)smToken->stringValue, 0, smThis->smLength);
smToken->stringValue[smThis->smLength] = 0;
Include = '$INCLUDE'
TmToken token; int i;
char c;

plOScan(smThis, &token);    /* Get file name */ do {
i = pl0ScSkip(smThis, 1);
c = smThis->smText[smThis->smLength-1];
} while(c !_ '\n' && i != 0); /* Skip to EOL or EOF
strcpy(smToken->stringValue, token.stringValue);

@PAGE 175 -- ScannerMaker Reference Manual

Unknown = Unknown; EndOfText = EndOfText;
%%SKIP
Blank = White+; -- Skip any white space Comment = -- [-\n]*[\n];-- and Ada style comments
%%END

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 176 -- ScannerMaker Reference Manual

B   ERROR MESSAGES

Error messages produced by ScannerMaker are output to the terminal, and if the option List Input; is set, messages are also output to the list file.
For a description of the format of error messages refer to Message Format in the ToolMaker System Description, page 49.
B.1 Message Explanations

The following list gives a brief summary of the error messages and in some cases the actions that should be taken by the user. An error message containing '%n', where n is a number, means that an insert string is inserted in that position during the actual generation of the message.
Messages with numbers less than 100 are messages common for all Makers. These are described in Messages Explanations in the ToolMaker System Description, page 50. Messages indicating license problems or limitations are described in License Errors in the ToolMaker System Description, page 51.
100 Parsing resumed.
This error specifies a point in the description file where parsing could be resumed after a wild error.
101 %1 inserted.
The token or tokens is inserted into the description file because the ScannerMaker thought it was missing.
102 %1 deleted.
The token or tokens is deleted from the description file because the parser thought it was wrongly inserted.
103 %1 replaced by %2.
The token is replaced with another token. More than one token can be replaced with one or more tokens.
104 syntax error, stack backed up.
Severe syntax error there the normal error recovery strategies failed and the parser was forced to do severe error recovery. The meaning of the scanner description is probably lost.
105 Syntax error.
An unspecified syntax error. This error message should not appear.

@PAGE 177 -- ScannerMaker Reference Manual

106 Parser stack overflow
107 Parse table error.
108 Parsing terminated.
These are errors in the scanner generator. Contact your ToolMaker contact person for bug report.
207 Can not overwrite table file "Al".
The protection of an existing table file prevents ScannerMaker to over-write it.
208 Can not overwrite list file "%1".
The protection of an existing list file prevents ScannerMaker to overwrite it.
209 Scanner "%1" already defined.
The scanner is already defined earlier in the description file.
210 Token "%1" already screened.
The token is already screened in this scanner.
211 Token "A1" not in vocabulary.
The token can not be found in the vocabulary.
212 External code already exist.
The external token code is already used in this scanner.
213 Token name already exist.
The token is already defined in this scanner.
214 Multiple matches of END OF TEXT token in scanner.
Only one token can be defined to match the end of text.
215 Multiple matches of UNKNOWN token in scanner.
Only one token can be defined to match unknown tokens.
216 END OF TEXT token not defined.
There is no token which match the end of text.
218 UNKNOWN token not defined.
There is no token which match unknown tokens.

@PAGE 178 -- ScannerMaker Reference Manual

220 String contains mapped or excluded character, or characters not in the current character set.
Only characters in the current character set are allowed within string tokens. Mapped or excluded characters are not allowed.
221 Automatically defined in "%1".
The string token is not defined in the scanner but it is automatically defined to match itself.
222 Not defined in "%l".

The token is not defined in the scanner.
223 Vocabulary file "%l" not found.

The vocabulary file can not be found.
224 Line number expected.
Line number is expected in the first field of the vocabulary file.
225 External code expected.

External token code is expected in the second field of the vocabulary file.
226 Old end of text symbol, converting to END OF TEXT.

The old end of text symbol ' $ ' is found. Convert it to the token EndOfText.
227 Token name expected.

Token name is expected in the third field of the vocabulary file.
228 Old format, using "main" as vocabulary.
Old format of vocabulary file. All tokens are considered to belong to the vocabulary main.
229 Scanner name expected.
Scanner name is expected in the fourth field of the vocabulary file.
230 End of line expected.

End of line is expected in the vocabulary file.
231 Must be one character long.

The character string must be one character long. The character may be quote character.

ScannerMaker Reference Manual


@PAGE 179

232 Set not uniquely mapped.
The set is not unique. That is, each character in the set must have a unique character equivalent or be skipped.
233 Token already defined.
Token is already defined.
234 Scanner not found.
The scanner reference is not found.
235 Token reference not found in scanner "%l".
The token referenced in the scanner is not found.
236 Token not defined.
The token is not defined in the scanner.
237 Number must be greater than or equal to the first number.
The first number in the general closure specification must be less than the last number.
238 Class contain mapped or excluded characters.
Mapped or excluded characters are not allowed in a class.
239 Token not defined.
The token is not defined in the definition section.
240 Scanner description file "%1" not found.
The description file can not be found.
241 The cut operator must lead to a final state.
The cut operator must be used in such as way that the character preceding it matches the last character in the regular expression.
242 Not accepted by "Al".
The screened token is not accepted by the token used to screen it.
243 %1 definition takes precedence (ambigous accepting state).
Two or more tokens have the same accepting state.

@PAGE 180 -- ScannerMaker Reference Manual

244 Old format, defines UNKNOWN with external code 0.
Old format of the vocabulary file implicitly defined unknown tokens to be 0.
245 Action not defined.
The action is not defined in the definition section.
246 Action already defined.
An action can only be defined once.
247 Name of set expected.
The name of the set being defined was expected.
248 Set already defined.
A set with the same name is already defined.
249 Unexpected end of set.
More characters are expected in the set.
250 Character already defined.
It is illegal to define the same character twice in a set.
251 Unknown token, ignored.
Unknown token found in the set.
252 Character %1 multiply defined in %2 set.
It is illegal to define the same character twice in a set.
254 Specified set %1 does not exist.
The set is not defined.
255 Vocabulary already defined.
Vocabularies must have unique name. A vocabulary with the same name has already been used in this description file.
256 Vocabulary not defined.
The vocabulary can not be found in the vocabulary file.
257 Scanner already defined.
A scanner with the same name is already defined in the same vocabulary.

@PAGE 181 -- ScannerMaker Reference Manual

258 Scanner not defined.
The scanner is not defined in the same vocabulary.
259 Token is not defined in this vocabulary.
The token must be defined in this vocabulary or be specified in the undefine section of the scanner.
260 Screening turned off, no other token may screen it.
No token was found in the scanner which could be used to screen the token. The token will be part of the scanner.
261 Token predefined in %1 scanner.
The token is predefined in the first scanner defined for the vocabulary.
262 Section already defined.
The specified code section can only be used once in the description file.
401 Scanner description file "%1" not found.
The scanner description file could not be found.
402 Trouble producing code.
It was not possible to generate any target language code. The problem may be that generated files could not be written due to protection problem, older protected files or protected current directory, or an error in the skeleton file.
405 Target language "%1" not officially supported.
This warning is issued if the target language is set to a language not officially supported. Note that the option value is case sensitive and the message may be caused by a typing error.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 182 -- ScannerMaker Reference Manual

C   DESCRIPTION LANGUAGE
This appendix contains a syntax summary of the ScannerMaker description language. For a full discussion of the language, see The ScannerMaker Description File on page 138.
For a brief discussion of the notation used in this description see appendix C in the ToolMaker System Description, SYNTAX NOTATION, page 52.


C.1 Language Syntax
<description file> :._
(<toolmaker section>) (<target code section>) (<set definition section>) (<general definition section>) (<vocabulary section>}

<toolmaker sections> :._
( <options section> ]
( <import section> I <srcp section>
<token section> }

<import section> :._
see the ToolMaker System Description

<srcp section> :._
see the ToolMaker System Description

<token section> :._
see the ToolMaker System Description

<options section>
'%%OPTIONS' (<directive>} ['%%END']

<directive> :._
<common directive> <optimize directive> <trace direvtive> <set directive> <pack directive> <screening directive> <list directive> <token size directive> <token limit directive> <exclude character directive>

<common directive> _ <target directive> <os directive> <prefix directive> <library directive> <escape directive> <width directive> <height directive> <generate directive> <force directive>

<optimize directive> ['NO'] 'OPTIMIZE'

@PAGE 183 -- ScannerMaker Reference Manual

<generate directive> :._
['NO'] 'GENERATE' <generate> ',

<generate> :.= 'SOURCE' 'TABLES'

<verbose directive> :._ ['NO'] 'VERBOSE' ',
<trace directive> :._ ['NO'] 'TRACE'

<set directive> .._ 'SET' <set name> ',

<set name> :._ <string>

<pack directive> :_ 'NO' 'PACK' 'PACK' <pack> {'
<screening directive>
'NO' 'SCREENING' ',
I 'SCREENING' <minimum token size> ',

<minimum token size> <number>

<list directive> :._
'NO' 'LIST'
'LIST' <list> {',   <list>)

<list>
'SCREENING' 'TOKEN'
.MAP,
'SET' 'NFA' 'DFA' 'RULE'

<escape directive> :._
'NO' 'ESCAPE' '
'ESCAPE' <escape character>'

<width directive> :._ 'NO' 'WIDTH' ' 'WIDTH' <width> ',
<width> .._ <number>
<pack>
'ROW' 'COL' 'LES' 'GCS' 'RDS' 'ERROR'
<pack>)

@PAGE 184 -- ScannerMaker Reference Manual

<height directive> :._ 'NO' 'HEIGHT' ' 'HEIGHT' <height>

<height> .._ <number>

<target operating system directive>

'OS' <operating system> ',
<operating system> :._ <string>

<target language directive> :._

'TARGET' <language> ',

<language> :._ <string>

<library directive> :._ 'LIBRARY' <library>

<library> :._ <string>

<prefix>
'PREFIX' <system name prefix>
<system name prefix> :. <string>

<token size directive> :._
'TOKENSIZE' <minimal token size> '

<token limit directive> ::=
'TOKENLIMIT' <maximal token size> '

<exclude character directive> ::'EXCLUDE, <exclude character> ',

<target code sections> ::= <declaration section> <context section> <export section> <code section> <reader section> <prehook section> <posthook section> <action section>

<declaration section> ::=
'%%DECLARATION' <target language code> ['%%END'3

<context section> :._
'%%CONTEXT' <target language code> ['%%END']
<code section> .._
'%%CODE' <target language code> ['%%END']

<export section> :._
'%%EXPORT' <target language code> ['%%END']

@PAGE 185 -- ScannerMaker Reference Manual

<reader section> :._
'%%READER' <target language code> ['%%END']

<action section> .._
'%%ACTION' <target language code> ['%%END']

<prehook section> :._
'%%PREHOOK' <target language code> ['%%END')

<posthook section> :._
'%%POSTHOOK' <target language code> ['%%END']

<general definition section> :._ <map definition section> <definition section>

<set section> :._
'%%SET' <set name> {<set>} ['%%END']

<set> :._
<character>
<hex digit> <hex digit>
<map section>
'%%MAP' (<character map>) ['%%END']

<character map> :._
<character class> ' ' <character class>

<definition section> :._
'%%DEFINITION' {<definition>) ['%%END']

<definition> .._
<definition name> _
[<selection rule>] [<action>]';'
<vocabulary section> :._
'%%VOCABULARY' <vocabulary name>
<token name> '=' <external token code> ';'} {<scanner section>]
<scanner section> :._
'%%SCANNER' <scanner name> [':' <scanner name>] [<screened token section>] [<undefine token section>] {<rule definition section>}

<screened token section> '%%SCREENING' {<token name> ';'}

<undefined token section> :._ '%%UNDEFINE' (<token name> ;'}

@PAGE 186 -- ScannerMaker Reference Manual

<rule definition section> :._ <rule section> <skip section>

<rule section> :._
'%%RULE' (<token rule>) ['%%END']

<token rule> .._
<token name>    <lookahead rule> [<action>]
<string>    _' <lookahead rule> [<action>]
<skip section> :._
'%%SKIP' {<skip rule>) ['%%END']
<skip rule> :._
<token name>    <lookahead rule> [<action>]
<string>    _' <lookahead rule> [<action>] ',
    <lookahead rule> :._
    <selection rule> ('/' <selection rule>]
    <selection rule> :._
    [<selection rule> '! '] <concatenation rule>
    <concatenation rule> :._
    [<concatenation rule>] <closure rule>
    <closure rule> :._
        <item>  '+' ')'
        <item>
        <item>
        <item>
        <item>
            '?'
            '{' <number> '}'
            '{' [<number>] - [<number>]
    <item>
        <definition name>
        <string>
        <character class>
            '(' <selection  rule> ')'
    <character class> :._
    [   {<character>) ']'
        (<character>) ']'
    <action> --

    '9696' <target language code> '%%'
Note that every keyword starting with ' %%' can be specified using both up

per or lower case letters and it may also be specified in plural.
C.2 Lexical Items
<upper case letter> :._ 'D' 'E' 'F' 'G' 'H'
'A' 'B' 'K' 'L' 'M' 'N' '0' 'P,
'I' 'J'

@PAGE 187 -- ScannerMaker Reference Manual

dower case a'


Y'
,R, I   'S' I   ,T, I   'U' I   ,V' I   'W' I   ,X,
letter> :._
'b' 'c'
'k'
z'
'd' '1'
'e'
'f' 'n'
,g,
'o' 'w'
'h' ,p,
'x'
<letter> :._
<upper case letter>

<digit> .._ '0'
'5,
<special • character> :._
* (• ' ')
<target language code> :._
any characters in the target language except the escape character, see The ScannerMaker Description File on page 138.
'1' '6'
'2'
'7'
<lower case letter>
'3' '8'
'4'
,9,
%,
<token name> :._
<letter> (<letter> I <digit> <definition name> .._
<letter> {<letter> I <digit> I _'}
* 'z'
<string> .._
''I (<letter> I <digit> I <special character>} ...

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 188 -- ScannerMaker Reference Manual

D   TARGET LANGUAGE DETAILS
This appendix describes the actual definition of the run-time environment by the generated scanner for different target languages.


D A 'c'


Types
typedef enum smScScanner { sm_vocabularyname_scannername_Scanner = scannercode,
} smScScanner;

typedef enum sm_scannerName_ScToken { sm_vocabularyname_tokenname_Scanner = tokencode,

} sm scannerName_ScToken;

typedef struct smScContextltem *smScContext;
typedef struct smScContextltem { int smSize; int smLength; unsigned char *smLength; int smLine; int smColumn; int smPosition; int smNextLine; int smNextColumn; int smNextPosition; smScScanner smScanner; code from context section
} *smScContext,smScContextItem;
Functions
int smScan(smThis,smToken) smScContext smThis; %(tokenType) *smToken;

smScContext smScNew(smScanner) smScScanner smScanner;

void smScDelete(smThis) smScContext smThis;

int smScSkip(smThis,smLength) smScContext smThis; int smLength;

int smScModify(smThis,smBuffar,smLength) smScContext smthis; int unsigned char *smBuffer; int smLength;

int smScCopy(smThis,smBuffer,smFrom,smTo) smScContext smThis; unsigned char *smBuffer;

@PAGE 189 -- ScannerMaker Reference Manual

int smFrom; int smTo;
int smScMapCopy(smThis,smBuffer,smFrom,smTo) smScContext smThis; unsigned char *SmBuffer; int smFrom;
int smTo;

void smScScrScanner(smScanner smOnOff) smScScanner smScanner; int smOnOff;

void smScScrToken(smScanner,smToken,smOnOff) smScScanner smScanner; sm_vocabularyname_Token smToken; int smOnOff;

void smScScrRule(smScanner,smToken,smOnOff) smScScanner smScanner; sm_vocabularyname Token smToken; int smOnOff;


D.2 'ansi-c' and 'c++'
This interface is used both for 'ansi-c' and 'c++'. Types
typedef enum smScScanner {
sm_vocabularyname_scannername_Scanner scannercode,

} smScScanner;

typedef enum sm_scannerName_ScToken f sm_vocabularyname_tokenname_Scanner = tokencode,

} sm_scannerName ScToken;

typedef struct smScContextltem *smScContext;
typedef struct smScContextltem { int smSize;
int smLength;
unsigned char *smLength; int smLine;
int smColumn; int smPosition; int smNextLine; int smNextColumn; int smNextPosition; smScScanner smScanner; code from context section
} *smScContext,smScContextltem;
Functions
int smScan(
smScContext smThis, %(tokenType) *smToken)

@PAGE 190 -- ScannerMaker Reference Manual

smScContext smScNew( smScScanner smScanner)

void smScDelete( smScContext smThis)

int smScSkip( smScContext smThis, int smLength)

int smScModify(
smScContext smThis,
int unsigned char *smBuffer, int smLength)

int smScCopy(
smScContext smThis, unsigned char *smBuffer, int smFrom,
int smTo)

int smScMapCopy(
smScContext smThis, unsigned char *smBuffer, int smFrom,
int smTo)

void smScScrScanner( smScScanner smScanner, int smOnOff)

void smScScrToken(
SmScScanner smScanner, sm_vocabularyname_Token smToken, int smOnOff)

void smScScrRule(
smScScanner smScanner, sm_vocabularyname_Token smToken, int smOnOff)


D.3 Object oriented 'c++' (proposal)
This is a suggestion how an object-oriented 'c++' interface may look like. Currently there exist no such interface. 'c++' users should use the 'ansi-c' interface to generate source code compilable with 'c++' compilers.
Types
typedef enum smScScanner { sm_vocabularyname_scannername_Scanner scannercode,

smScScanner;

typedef enum sm scannerName ScToken ( sm_vocabularyname_tokenname Scanner = tokencode,

) sm_scannerName_ScToken;

@PAGE 191 -- ScannerMaker Reference Manual

class smScContextItem {
public:
int smSize; int smLength;
unsigned char *smLength; int smLine;
int smColumn; int smPosition; int smNextLine; int smNextColumn; int smNextPosition; smScScanner smScanner;
public:
int smScan(
%%(tokenType) *smToken); smScContext(
smScScanner smScanner); -smScContext O ;
int smScSkip(
int smLength); int smScnodify(
unsigned char *smBuffer,
int smLength); int smScCopy(
unsigned char *smBuffer,
int smFrom,
int smTo); int smScMapCopy(
unsigned char *smBuffer,
int smFrom,
int smTo);
declarations from context section
};

void smScScrScanner( smScScanner smScanner, int smOnOff)

void smScScrToken(
smScScanner smScanner, sm_vocabularyname Token smToken, int smOnOff)

void smScScrRUle(
smScScanner smScanner, sm_vocabularyname Token smToken, int smOnOff)

@PAGE 192 -- ScannerMaker Reference Manual


==================================================
Part IV
ListerMaker
Reference Manual

@PAGE 195 -- Part IV Contents
@PAGE 197 -- ListerMaker Reference Manual


@PAGE 198 -- ListerMaker Reference Manual

2   CONCEPTS AND ASSUMPTIONS

2.1 ListerMaker and Lister

ListerMaker is a software tool to produce Listers. The term Lister is used to describe a software component or subroutine package designed to handle messages issued during analysis of an input, typically error and warning messages. A Lister also allows production of listing files containing the input and any associated messages. It is also possible to retrieve the messages one by one from the Lister.
ListerMaker is the tool and Lister is thus the subroutine package produced by that tool.

2.2 Source Positions

The most important concept in ListerMaker is the source position. A source position is an identification of a position in the source (input) worked upon by the application (i.e the program written by you, the tool writer). Although perfectly usable anyway, conceptually this is the first assumption made by ListerMaker, that the application is reading its input from a file. A source position is a structure containing a column, a line and optionally a file number.
A source position is sent to Lister together with every message logged. This makes it possible for the Lister to find and show the source corresponding to the error and to place the message at the correct point in the output. A message that should be placed at the end of the listing of a file should have the line component set to 0 (zero). All such messages are collected and printed after listing the file. In case multiple files are handled, global messages, i.e. messages pertaining to the complete input can be collected and shown after all files are listed if the file component is set to -1.
Note: The automatic source position calculation of ScannerMaker can be used to create the line and column part of the source position information.

2.3 Messages

A message is actually a number of different things. The first meaning of a message is one number and corresponding text in the Message section in the description file (see below). This type of message is a template for actual messages output to the end-user.
The second use of the term is the call to Lister to log a message, this call carries among other things a message number referring to the message in the previous sense, i.e it refers to a template found in the description or message file.

ListerMaker Reference Manual


@PAGE 199

The third use is the actual presented text together with the source where the error was discovered. This is produced by the Lister using a call to a list function after all messages have been logged and shown on the terminal or the screen.
A final observation on error messages is that although the term is error message it does not actually have to indicate errors (other classes of messages handled by a Lister is Informational, Warning, Fatal and System messages) but is used for convenience throughout this document. ListerMaker does not place any restrictions or assumptions on what to do when a message is logged, the recovery, abortion of execution or other action is totally up to the implementor.


2.4 Error Message Templates and Insert Strings

As described above an error message starts out as a template in the description file. These templates consist of a number used to identify the message and a string which is the actual message each taking up one line in the error message file. For example
102 '%l deleted.';

The message string may contain insertion markers ('%d', where d is a digit). This allows a message to be customised during run-time by inserting additional information in the message clarifying the meaning, such as the name of an identifier. The needed number of insert strings must be concatenated and sent to Lister in the log call. Lister will then extract the insert strings and insert them at the appropriate places in the message before presenting it to the user.


2.5 Severities

A logged message is also associated with a severity code. This code is not implied by the message code, as it sometimes might be handy to be able to log a message with the same code but with different severities. An example of this is the insertion of a symbol by a parser, if the symbol was just a comma or semicolon, this might be considered a Warning, but if the inserted symbol was an identifier it surely must be an Error as the parser has no idea as to what identifier the programmer meant.
ListerMaker (and the Lister) defines the following severity levels (in order of increasing severity):
sevINF, sevWAR, sevERR, sevFAT, sevSYS

corresponding to Informational, Warning, Error, Fatal and System messages. Any semantic meaning of these, except for their ordering, is not assumed by the Lister, it is only used as a classification of the messages.

@PAGE 200 -- ListerMaker Reference Manual

The most serious severity logged so far may be read by the function 1mSeverity ().

2.6 Listing Types

In order to direct Lister to produce the selected kinds of information in the listing the generated Lister also defines an enumerated type. One of the parameters to 1mLi s t ( ) is a set of values from this type.
Value   Description
11 SUM  Print a summary of the number of messages found
liERR   Print source lines with messages associated to them in the list
1 i0K   Print source lines without any messages in the list 1 i INCL List and show (as appropriate) included files 1 iHEAD Print a header on top of all pages
Lister also has a shorthand notation for two common combinations of these, 1 iTINY, which is a tiny listing including a header and source for just those lines that have messages associated to them and a summary, and 11 FULL, which also shows the source lines without messages. Normally a tiny list is useful to present on the screen, and a full list if listing to a file.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 201 -- ListerMaker Reference Manual

3   LISTER PRODUCTION

3.1 The ListerMaker Description File

The main information necessary to produce a Lister is the message templates. These are normally written in a description file used by ListerMaker.
To inform ListerMaker how your Lister is to work there is a number of options that you may choose. These include for example whether to include routines for list production and the prefix for all the externally visible functions in the produced Lister.
After setting up a directory using toolmake there should exist a default description file prepared with all necessary options set to their default values and some example messages. An example of a ListerMaker description file is included in appendix A, THE PLIO EXAMPLE, on page 220.
The structure of the ListerMaker description file is
<description file>  _
<toolmaker sections>
<message section> { <message section> }
<toolmaker sections> :._
[ <options section>
{ <import section> I <srcp section> }

The import and srcp sections are further described in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30. These sections are normally located in the ToolMaker description file and should be put in the ParserMaker description file only when developing a stand-alone
Lister.

3.1.1   Lexical items

Symbols in the ListerMaker description language are constructed from using upper case letters from the ISO-8859-1 character set, lower case letters (ISO8859-1) and digits.
<letter> :._ <upper case letter> I <lower case letter>
<digit> :._
'0' 'l' '2' '3' '4'
'5' '6' '7' ,8,
<number> :._ <digit>+   I <digit>   }
<name>  <letter> {<letter>
<quoted string> :._
{<letter> I <digit> I <special character>} ...

@PAGE 202 -- ListerMaker Reference Manual

3.1.2   The Options Section

<options section>   _
'%%OPTIONS' <directive> (<directive>)

<directive> .._
<common directive> <listings directive> <include directive> <message directive> <limit directive>
In the options section various options can be set. The available options for ListerMaker are described below. The term default describes the initial setting unless otherwise stated in the ToolMaker Common Description file when appropriate (see The ToolMaker Description File in the ToolMaker System Description, page 27).
['%%END' I
These options can be overridden by options given on the command line when ListerMaker is invoked (see THE LISTERMAKER COMMAND on page 206). If an option is not specified its default value is used. The default options are:
No Verbose;
Target 'ansi-c'; Os 'SunOS'; Prefix 'lm';
Library '$TMHOME/lib/ansi-c'; Escape ...
width 78; Height 60; Generate source; No Force; Listings single; Include; Limit 100; Messages embedded;
Note however that the settings of common options in the ToolMaker Common Description file influences the default values (see The Options Section in the ToolMaker System Description, page 30, and Prefix Management in the ToolMaker System Description, page 42).

3.1.2.1 Common Directives

<common directive> _ <prefix directive> <escape directive> <target directive> <os directive> <library directive>
The common directives are directives available for all Makers in the ToolMaker kit. For a detailed description of these refer to The Options Section in the ToolMaker System Description, page 30. The directives listed above are the directives relevant for ListerMaker, and if used overrides settings and default values from the ToolMaker Common Description file.

@PAGE 203 -- ListerMaker Reference Manual

The prefix directive does not inherit its default value, instead it defaults to 'lm' if not explicitly set in the .tmk file. If set in the ToolMaker Common Description file and not used in the ListerMaker Description file it defaults to the system prefix (the value set in the ToolMaker Common Description file).

3.1.2.2 The Listings Directive

<listings directive> ::
'LISTINGS' <listings option>
{',' <listings option>} ', ['NO'] 'LISTINGS'
<listings option> ::=
'SINGLE' I 'MULTIPLE' I 'SEPARATE'

The listings directive tells ListerMaker to include the functions for producing listings in the generated Lister module. In cases where only message by message retrieval using the lmMsg () function is used the NO LISTINGS option may be specified to reduce the amount of code in the Lister.
Under certain circumstances it is necessary to make a list of multiple source files, for example if the application is checking the interfaces between program modules. If this directive is specified, ListerMaker will generate a ImL i s tm () function, which may be used instead of 1mL i s t () to achieve this. See Multiple Input Files on page 210.
The functions to use for separate listings of multiple input files (see Separate Listing of Multiple Input Files on page 211) is only generated into the Lister if the value SEPARATE is selected.
The default value is.
Listings SINGLE;

3.1.2.3 The Include Directive

<include directive> :._ ['NO'] 'INCLUDE' ',

The include directive specifies if using and nesting source files shall be allowed. If NO INCLUDE is specified, file handling will not be included in the generated Lister.
The default value is:
Include;

3.1.2.4 The Limit Directive

<limit directive> ::= 'LIMIT' <number' ';

@PAGE 204 -- ListerMaker Reference Manual

The Messagelimit directive indicates the maximum number of messages possible to log using lmLog () . Any integer greater than 0 (zero) is allowed. Note that also the number of calls to lmLiEnter (), lmLiExit (), lmLiOf f (), lmLiOn (), 1mLiPage (), lmSkipLines () (i.e. all COLLECTING phase functions) are included in this calculation.
The default value is:


Limit 100;

3.1.2.5 The Message Directive

<message directive> .._
'MESSAGE' <target option> ',
<message option> :-'FILE' I 'EMBEDDED'
The message directive tells ListerMaker whether the messages shall be put in a separate file to be read at run-time or embedded in the generated Lister source code.


The default value is:


Message EMBEDDED;


3.1.3   The Messages Sections

<messages section> .._ '%%MESSAGES' <name> [<message> {<message>}] ['%%END']

<message> :._ <number> <quoted string> ',
Multiple message sections may be specified. Using the generated initialisation call (1mLilnit ( )) the section used may be selected during run-time. Example:


%%MESSAGES english
10 'Syntax error.'; 11 'Illegal symbol.';
%%MESSAGES swedish
10 'Syntaxfel.';
11 'Felaktig symbol.
%END

3.2 The ToolMaker Common Description File

Unless ListerMaker is the only Maker used, common declarations of the source position and the token structures should be placed in the ToolMaker

@PAGE 205 -- ListerMaker Reference Manual

Common Description file which is described in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30. Otherwise these two sections may be specified in the ListerMaker Description file, removing any need for the ToolMaker Common Description file.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 206 -- ListerMaker Reference Manual

4   THE LISTERMAKER COMMAND

The invocation of ListerMaker is performed by a command of the form
lmk [-help] [<options> ...] <file>

The special option -help gives a short help of available options and their meaning.

4.1 Parameters

The ListerMaker command takes only one argument, the name of a description file. The description file contains a description of the lister to be generated using definitions as described in The ListerMaker Description File on page 201. The argument may appear anywhere on the command line except between an option name and its arguments. The default extension for the ListerMaker description file is Imk.

4.2 Options

One or more options may be specified on the command line overriding any specified options in the options section in the description file.
All options are available as command line options, the general format is:
-[-]optionname [optionvalue]
The option names corresponds exactly to the names given in the section The Options Section on page 202. The option value (if required) corresponds to allowed values of the option. To turn an option on, one dash is used, to turn an option off two dashes are used. For example, to turn the verbose option on, use -verbose, to turn it off, use --verbose, which is equivalent to specifying NO VERBOSE in the options section.
Please refer to the corresponding options and directives in The Options Section on page 202 for a detailed description of the various options. The general command line option format is described in Command Line Option Format in the ToolMaker System Description, page 40.
The special option
-help

produce a verbose listing of the usage format of the command. Each argument and option are given a short explanation. Refer to The Options Section on page 202 for details on the various options.

@PAGE 207 -- ListerMaker Reference Manual

In addition the following special option is available from the command line: -lmt <file>
This options may be used to direct ListerMaker to write the intermediate tables on a file other than the default.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 208 -- ListerMaker Reference Manual

5   LISTER RUN-TIME USAGE
This chapter describe the functions in the run time part of ListerMaker, the Lister, and how your application accesses these functions.


5.1 Principles of Operation

The first thing to do is to initiate the listing system. This is done by calling the function 1mLiInit ( ) , preferably at the beginning of the main program. This call includes the name of the input file and the string to insert in the header of any listing files produced later and the message section that is to be used for templates. If message templates were placed in a separate file (by the use of the appropriate option) the name of the file containing the error message templates should also be given in this call.
The next step is to start analysis of the input, for example by initiating a ScannerMaker generated scanner and calling the parsing routine in the ParserMaker generated parser. During this analysis lexical and syntactical errors discovered are logged by the error handling procedures in the error handler module used by ParserMaker (see ParserMaker Reference Manual). The supplied ListerMaker description file contains error message templates for the errors automatically handled here.
Messages are logged using the function 1mLog () . This function is also used by the standard error handler module in the parser. Of course this module may be replaced by code written by you, but as it stands it is tuned to directly work with a ListerMaker produced Lister.
If you are not using a ParserMaker generated parser you might still want to use Lister, and this is of course possible. Just use 1mLog () to log the messages. This is also what you do for example during later passes of your application when you want to log a message.
The last step in using Lister is to use it to present the messages to the user. This is performed by calling 1mList ( ) which creates a listing presented in a file or on the screen. The information contained in the listing is controlled by parameters to ImList () , examples of information possible to select are whether only messages or source lines corresponding to the errors or all lines should be shown. This is performed by re-reading the input files and for each line produce the appropriate output (input lines and/or messages).
An alternate way of presenting the messages for a user is to use the 1mvsg ( ) function. This function will return the message text for a any selected message together with its source position. This information may then be used to position the message text on a screen for example.
If multiple files are to be listed the source position structure must contain a file component. This field should be initialised with a unique value for each in

@PAGE 209 -- ListerMaker Reference Manual

stance of input files. To use the value from a simple counter which is incremented for each newly opened file is normally adequate.

5.1.1   Phases

Lister works in three different phases, UNINITIALISED, COLLECTING and RETRIEVING. During the UNINITIALISED phase no calls except to initiate the Lister is legal. Calls to procedures logging messages is allowed in the COLLECTING phase, and calls for producing lists, retrieving messages and printing text is only allowed in the RETRIEVING phase. Transition between the COLLECTING and RETRIEVING phases is performed by the first call

to 1mList(),1mListm(),1mListsi() or lmMsg().

To sum up, the following functions are available in each phase:

INITIATING: lmLilnit()

COLLECTING: lmLog() lmLogv()

ImLiOn() ImLiOff() 1mLiPage() 1mSeverity()

RETRIEVING:
ImList() lmMsg() ImSkipLines() lmLiPrint() ImSeverity() lmLiTerminate()

@PAGE 210 -- ListerMaker Reference Manual

5.1.2   Include-handling

In some cases a method of handling nested files is needed. This is for example the case with so called include-files in some programming languages. ListerMaker supplies functions to handle this feature.
Suppose that we want to create a 'c'-preprocessor. The preprocessor has a directive, #include, which allows inclusion of secondary files containing 'c' source.
To solve the problem of creating lists of such input using ListerMaker the function lmLiEnter () is used. When encountering the #include directive this function should be called with the name of the new (included) file and a source position where the file should be inserted (normally at the first position on the line following the #include directive.
During the RETRIEVING phase any messages logged using source positions indicating this included file will be shown (or returned using imMsg ( ) ) before messages occurring after the #include directive in the top level file. So all messages are sorted correctly.
Note that the f i 1 e component of the source position structure should differentiate between every instance of an included file since even if the same file is included more than once the context is different each time and different messages may be generated for every instance depending on the context.
The following extra functions are available if the include option is used: COLLECTING:
lmLiEnter()

lmLiExit()

5.1.3   Multiple Input Files

Another major feature of Lister is the ability to handle listing of multiple toplevel input files. These files have no hierarchical relations as is the case with included files, as described above.
As opposed to the include file handling this is used when multiple files are worked upon at the same time, for example a file compare program or a module interface verifier. This kind of applications require that a small number of related input files are analysed (the files having no hierarchical relation to each other). When creating a listing the files should appear in the same listing file, but separated, not nested.

@PAGE 211 -- ListerMaker Reference Manual

This requires an array of file names, each index corresponding to the file number used in the source position structure, to be passed to Lister, as is the case in the parameter list for the 1mLi s tm () function, which is designed for this purpose. In this case the file numbers for the top level files must be from zero and up. Any further files may have any number.
Note: this feature is possible to use together with the include-feature, meaning that a number of top level files are listed together, each having (possibly) nested input files.

The following extra functions are available if the Listings multiple; option is used:
RETRIEVING:
* ImListm()

5.1.4   Separate Listing of Multiple Input Files

The listing of multiple input files can also be handled separately as opposed to the multiple handling described above. This means that a call to a function (1mL i s is ( ) ) must be performed for each of the files. This makes it possible to handle output (using 1mLiPrint ( )) between listings of each file.
The following extra functions are available if the Listings separate; option is used:
COLLECTING:
lmLocSeverity()

lmResLocSeverity() RETRIEVING:

* lmListsi()
* lmLists()
* lmListse()

5.2 Run Time Interface

Below all functions in a Lister are described with their default prefix, lm By using the option Prefix this may be changed to any selected string.


@PAGE 212 -- ListerMaker Reference Manual

5.2.1   Constant: lmSEPARATOR

This character constant contains the value to be used as separator between concatenated insertion strings. Thus the operation to send two insertion strings to a message in one 1mLog () call is to concatenate the two strings separated with the value 1mSEPARATOR, and then to send the resulting string as the insertion string in the 1mLog () call.

5.2.2   Type: lmMessages

This type contains the enumerated values of the names of the sections given in the Message sections in the description file. There is one value for each named Message section constructed by prepending the lister prefix and an underscore, and appending an underscore and the text 'Messages' to the name given to the section, e.g. if the section was called 'english' the corresponding constant is called
lm-ENGLISH-Messages

One of these values must be transferred in the call to the 1mLi Ini t ( ) function to indicate which set of message templates to use.

5.2.3   Type: lmSev

This enumerated type has all severities exported from Lister as its value set. Values from this type may be combined to form sets used in 1mList () .
An 1mSev constant containing the set of all severities (sevOK, sevINF, sevWAR, sevERR, sevFAT, sevSYS).

5.2.5   Type: lmTyp

This enumerated type is used to indicate selected information to include in the listing file (or on the screen).
Value   Description
l iSUM  List a summary of found messages.
1iERR   List source for lines with messages.
Value sevOK sevINF sevWAR sevERR sevFAT sevSYS
Description
OK severity, no message. Informational message. Warning message. Error message. Fatal error message. System error message.

5.2.4

Constant: sevALL

@PAGE 213 -- ListerMaker Reference Manual

1i0K    List source for lines without messages.
l i INCL List source lines and messages from included files as indicated by
the presence of 1iERR and 1iOK flags.
1 iHEAD Print a header on each page in the listing file.

5.2.6   Constant: liTINY

A set of lmTyp values appropriate for a tiny list, for example on the screen. Contains liSUM, liERR, 1iINCL and 1iHEAD.

5.2.7   Constant: liFULL

A set of lmTyp values appropriate for listing to a list file. Also contains 1i0K, so as to also show source lines for which there are no messages.

5.2.8   Function: imLiEnter()

lmLiEnter(srcp, start, file)
srcp : IN %%(srcpType) start : IN %%(srcpType) file IN STRING

If so configured the generated Lister is capable of handling nested files (include files in programmer terminology). A call to the lmLiEnter () function during message collection indicates where the included file should be inserted. The srcp parameter indicates the source position where the entered file should be inserted, and start where in the entered file to begin, normally this should indicate the first column on the first line. The file component should be set to a unique value indicating this instance of the included file. 1mLiEnter () is only callable in COLLECTING phase.

5.2.9   Function: lmLiExit()

lmLiExit(srcp)
srcp : IN %%(srcpType)

Prematurely exit from a nested file. Using this function is analogous to saying that the end of the file is earlier than the physical end of file. srcp is the source position where to place the simulated end of file. Should only be used in special cases and is only allowed in COLLECTING phase.

5.2.10  Function: lmLilnit()

lmlnit(header, source, section, message)
header IN STRING source : IN STRING section : IN lmMessage message  IN STRING



@PAGE 214

ListerMaker Reference Manual
Initiates the listing system. Only allowed in UNINITIALISED phase (the call changes phase to COLLECTING). header is the string to insert in the page header on every page of any listing file. This could for example contain a version identification. The file name of the top level source file is passed in the source parameter, the constant indicating which section of messages to use in section and the name of the message template file in message.
Note: If message templates are placed in the source instead of in a separate message file (by use of the ' Messages EMBEDDED' option) the last parameter, message, is not available and should not be given.

5.2.11  Function: ImList()

ImList(outfnm, lines, columns, listtype, severities)
outfnm IN STRING lines  : IN INTEGER
columns IN INTEGER listtype IN SET OF 1mTyp
severities : IN SET OF lmSev
The lmList () function produces a list consisting of the requested information, such as source lines, error messages and page headers on a specified file or on the terminal. It is callable only in the COLLECTING (the first call changes phase to RETRIEVING) and RETRIEVING phases. The file name for the list is passed in out fnm, if it is equal to "" (the empty string) the result is a listing on the screen (standard error). lines specifies the numbers of lines per page on the output file, if equal to 0 (zero) no paging is performed. columns specifies the number of output columns. A set of values from the lniPyp values is sent in the 1 i s ttype parameter specifying the information to be listed. seventies should contain a set of values from the lmSev type indicating which severities to include in the listing.

5.2.12  Function: ImListm()

lmListm(outfnm, lines, columns, listtype, severities, files)
outfnm : IN STRING lines : IN INTEGER
columns : IN INTEGER listtype: IN SET OF 1miTyp
severities : IN SET OF 1mSev files : IN ARRAY OF STRING
Same as ImLi s t () but allows for listing of multiple input files. This allows an application to e.g. analyse a number of input files and still produce one listing file. Note that this is not the same as the include handling (see Includehandling on page 210 and Multiple Input Files on page 210 for a comparison). Instead each input file is listed separately with a page break between each one. The extra parameter files is an array of strings with the file names of the files to list. The last element must be a NULL pointer.

@PAGE 215 -- ListerMaker Reference Manual

This function is only available if the Listings multiple; is used. 5.2.13   Function: lmListsi()

1mListsi(outfnm, lines, columns, listtype, severities)
outfnm IN STRING
lines : IN INTEGER columns : IN INTEGER listtype: IN SET OF ImTyp
severities : IN SET OF ImSev

This function initialises the lister to start separate listing (see Separate Listing of Multiple Input Files on page 211). This function does not produce a complete listing, instead the function ImLists () needs to be called once for each file, and the terminating function 1mListse () after completing the listing.
The parameters have the same interpretation as for 1mList () . 5.2.14   Function: lmLists()

lmListse(severities, fno, fnm)
severities : IN SET OF ImSev fno INTEGER
fnm : STRING

The function performs listing of one file while using separate listing (see Separate Listing of Multiple Input Files on page 211). A call to 1mLi s is i ( ) must first be performed to set it up, then multiple calls to 1mLi s t s () can be performed until all files have been handled. Between calls other retrieving phase functions can be called (e.g. 1mLiPrint () to print extra information).

5.2.15  Function: ImListse()

lmListse(severities) severities : IN SET OF ImSev

This function terminates the listing of separate files (see Separate Listing of Multiple Input Files on page 211) by printing the global messages. The severity parameter indicates which severities to include in the global messages section.

5.2.16  Function: ImLog()

ImLog(srcp, ecode, sev, istrs)
srcp    IN %%(srcpType) code : IN INTEGER

@PAGE 216 -- ListerMaker Reference Manual

sev : IN 1mSev istrs : IN STRING

Collects (logs) a message together with source position information (srcp) to be expanded and sorted for later retrieval. It is only callable in the COLLECTING phase. code identifies the message template from the message template file to be used. The severity associated with the message is indicated in sev. Concatenated insert strings are passed in istrs, i.e. one string for each insertion marker in the template, separated by the ImSEPARATOR character constant.

5.2.17  Function: lmLogv()

1mLogv(srcp, ecode, sev, ...)
srcp : IN %%(srcpType) code IN INTEGER sev : IN 1mSev

Corresponds to the function ImLog () but uses the 'c'-language feature of variable number of arguments. This greatly simplifies the logging of messages having multiple insert strings.
Note: The function is only available in the 'c' target languages. Note: The parameter list must be terminated by a NULL value. 5.2.18   Function: lmMsg()

1mMsg(i, srcp, msg) : INTEGER
i : IN INTEGER
srcp    OUT %%(srcpType) msg OUT STRING returns INTEGER

Retrieves logged messages one by one. For each call the i'th message is retrieved, the source position of the message is returned in the out parameter
s rcp and the message text in msg. ImMsg () returns the index, i, if the message was found, else a 0 (zero) is returned. This can be used to determine that there where no more messages to retrieve. Allowed in the RETRIEVING and COLLECTING phases (first call changes phase to RETRIEVING).

5.2.19  Function: lmLiOff()

1mLiOff ()Off (srcp) srcp : IN %%(srcpType)

The function of 1mLiof f () is to turn off the listing from a specified source position, srcp. Only allowed in COLLECTING phase.

@PAGE 217 -- ListerMaker Reference Manual

5.2.20  Function: lmLiOn()

1mLiOn(srcp)
srcp : IN %%(srcpType)

Turns listing on again from source position s rcp, after it has been turned off. Callable only in COLLECTING phase.

5.2.21  Function: lmLiPage()

lmLiPage(srcp, lines)
srcp : IN %%(srcpType) lines : IN INTEGER

Produces a conditional or unconditional page break in the output listing at a specified source position, srcp. If there are less than lines lines more available on the current listing page a page break is performed otherwise not. Zero means an unconditional break. 1mLiPage () should only be used in COLLECTING phase.

5.2.22  Function: lmLiPrint()

1mLiPrint(line) line : IN STRING

Print a line in the current output file. After each call to ImL i s t () (or between consecutive calls to 1mListse ()) it is possible to print additional lines in the output file. As long as imList() is not called again (or ImLiTerminate () !) each line will be appended to the listing file. Each call prints the contents of the parameter and performs a new line in the listing file or on the terminal. Page and line breaks are handled correctly. Allowed in RETRIEVING phase only. 1 ine is the string to be printed.

5.2.23  Function: lmLocSeverity()

sev = lmLocSeverityO returns lmSev

The function 1mLocSeveri ty () may be used to read the highest severity logged since the reset of a special local severity variable (see Function: ImResLocSeverityO on page 217) This function is callable both in COLLECTING and RETRIEVING phases and only available if Listings separate; is used.

5.2.24  Function: lmResLocSeverity()

1mResLocSeverity()

@PAGE 218 -- ListerMaker Reference Manual

The lmResLocSeverity ( ) resets the special local severity variable available when the Listings separate; option is in effect.
Note: the implementor is completely responsible for the use and resetting of the local severity variable.

5.2.25  Function: lmSeverity()

sev = 1mSeverity() returns 1mSev

To read the highest severity logged so far the procedure 1mSeverity ( ) may be used which returns a value from the 1mSev value set. This function is callable both in COLLECTING and RETRIEVING phases.

5.2.26  Function: lmSkipLines()

SmSkipLines(lines) lines : IN INTEGER

Performs a conditional page break in the output file. As with lmLi Print ( ) this function performs its output in the current output file or on the terminal. lmSkipLines () corresponds to the COLLECTING phase function ImLiPage ( ) , but may only be used in RETRIEVING phase. lines contains the number of lines at least available to not make a page break.

5.2.27  Function: lmLiTerminate()

lmLiTerminate ()

Terminates the Lister. No more lists may be produced. Lister is prepared for a new 1mLi Ini t () call. Allowed only in the RETRIEVING phase (the call changes phase to UNINITIALISED).


5.3 Messages Templates

5.3.1   Insertion Markers

An insert string supplied in a 1mLog () call is inserted into the message template fetched from the message file. The insert string may contain multiple strings separated by the special character ImSEPARATOR exported by Lister. The insertion marker is the character '%' followed by a number indicating which part of the string and should be placed in the template where the corresponding part of the insert string should be inserted. Thus the insert string supplied to 1mLog () must contain at least as many 1mSEPARATOR separated parts as there are insertion markers in the message text.

@PAGE 219 -- ListerMaker Reference Manual

5.3.2   Reserved Numbers

The following message numbers are reserved and should always be available if the generated Lister is used to produce listings (i.e. it is not necessary if only message retrieval using ImMsg () is used).
1) Heading string (may include insertion markers, position of insertion marker indicates where to insert any insertion strings sent in the lmLiInit () call).

2)  Message text for no errors or warnings (sevERR or sevWAR).

3)  Message text for no detected warnings (sevWAR).

4)  Message text for no detected errors (sevERR).

5)  Message text for number of detected informational messages (sevINF). An insertion marker is used to indicate where to insert the number.

6)  Message text for number of detected warning messages
(s evWAR). An insertion marker is used to indicate where to insert the number.

7)  Message text for number of detected error messages (sevERR). An insertion marker is used to indicate where to insert the number.

8)  Message text for maximum number of messages exceeded.

By altering the templates in the description file these system messages may be customized for different languages or other formats.
Note: The reserved message templates must be available in all message sections.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 220 -- ListerMaker Reference Manual

A   THE PL/O EXAMPLE

This example is a part of the overall example used throughout the ToolMaker documentation. In ToolMaker System Description there is a detailed walkthrough of the main parts of the example. This appendix contains the files relevant for ListerMaker.
A.1 plO.lmk -- The ListerMaker Description File -------------------------------------------- ---------
pl0.lmk Date: 1993-06-10/toolmake p10 -- ListerMaker description file
------------------------------------------------------Created:  1993-04-27/reibert@roo Generated: 1993-06-10 12:47:14/toolmake v2,rO,c7
------------------------------------------------------
%%OPTIONS Include;

%%MESSAGES English
0   'PL/O Analysis Tool %1';
1   'No warnings or errors detected.';
2   'No warnings issued.';
3   'No errors detected.';
4   %1 informational message(s) produced.';
5   '%1 warning(s) issued.';
6   '%1 error(s) detected.';
7   'Maximum number of messages exceeded.';
100 'Parsing resumed.';
101 '%1 inserted.';
102 '%1 deleted.';
103 '%l replaced by %2.';
104 'Syntax error, stack backed up.';
105 'Syntax error.';
106 'Parse stack overflow.';
107 'Parse table error.';
108 'Parsing terminated.';
199 'File %1 not found.'; %%END

ListerMaker Reference Manual

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 221

B   ERROR MESSAGES

For a description of the format of error messages refer to Message Format in the ToolMaker System Description, page 49.
B.1 Message Explanations

The following list gives a brief summary of the error messages and in some cases the actions that should be taken by the user. Messages with numbers less than 100 are messages common for all Makers. These are described in Messages Explanations in the ToolMaker System Description, page 50. Messages indicating license problems or limitations are described in License Errors in the ToolMaker System Description, page 51.
200 Message section "%l" already defined.
The indicated name was already used for another section of error messages.
300 At least one messages section is required.
At least one section with error messages must be defined.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 222 -- ListerMaker Reference Manual

C   TARGET LANGUAGE DETAILS
This appendix lists the actual definition of run-time elements exported by ListerMaker. The following sections contain this information per target language.
(s rcpType) denotes the type name defined for the source position structure in the srcp section in the ToolMaker control file (see appendix A, THE PL/0 EXAMPLE, on page 220 and The ToolMaker Description File in the ToolMaker System Description, page 27). Functions, types and constants prefixed by im uses the 1isterPrefix (see The Messages Sections on page 204).
C.1 'c' Types

typedef enum lmSev {
sevOK = (1«0),
sevINF  (1<<I),
sevWAR  (1<<2),
sevERR  (1<<3),
sevFAT  (1<<4),
sevSYS  (1<<5)
} 1mSev;
typedef enum lmTyp {
    liSUM   = (1«0),    /*  Summary */
    liERR   (1<<1), /*  Erroneous source lines */
    liOK    - (1<<2),   /*  Correct source lines */
    liINCL  (1<<3), /*  Look also in PUSHed files */
    liHEAD  (1<<4)  /*  Heading */
}   1mTyp;
typedef enum lmMessages lm XXXX Messages,

} lmMessages;


Constants
#define 1mSEPARATOR ((char)Oxff)

#define 1iTINY (liSUMjliERRIliHEADIliINCL) #define liFULL (liTINYlliOK)

#define sevALL (sevOKIsevINFIsevWARIsevERRisevFATIsevSYS)
Functions
void lmLilnit(header, src, msect) char header[]; char src[];
1mMessages msect;

ListerMaker Reference Manual


@PAGE 223

void lmLog(pos, ecode, sev, istrs) %%(srcpType) *pos; int ecode;
1mSev sev; char istrs[];

void lmLiOff(pos) %%(srcpType) *pos;

void lmLiOn(pos) %%(srcpType) *pos;

void lmLiEnter(pos, start, fnm) %%(srcpType) *pos; %%(srcpType) *start; char fnm[];

void lmLiExit(%%(srcpType) *pos);

void lmLiPage(pos, lins) %%(srcpType) *pos; int lins;

1mSev lmSeverity(); lmSev lmLocSeverity(); void 1mResLocSeverity();
void lmList(ofnm, lins, cols, typ, sevs) char ofnm[];
int lins; int cols; lmTyp typ; 1mSev sevs;

void lmListm(ofnm, lins, cols, typ, sevs, char ofnm[];
int lins; int cols; 1mTyp typ; lmSev sevs; char *fnms[];

void lmListsi(ofnm, Tins, cols, typ) char ofnm[];
int Tins; int cols; 1mTyp typ;

void lmLists(sevs, fno, fnm) 1mSev sevs; int fno;
char *fnm;

void lmListse(sevs) 1mSev sevs;

int lmMsg(i, pos, msg) int i; %%(srcpType) *pos; char *msg);
fnms)

@PAGE 224 -- ListerMaker Reference Manual

void lmLiPrint(str) char str[];
void lmSkipLines(lins) int lins;

void lmLiTerminate();
C.2 'ansi-c' and 'c++'


Types
typedef enum 1mSev {
sevOK   (1<<O),
sevINF =    (1<<l),
sevWAR  (1<<2),
sevERR  (1<<3),
sevFAT  (1<<4),
sevSYS  (1<<5)
} lmSev;
typedef enum ImTyp (
    liSUM = (1«0),  /*  Summary */
    liERR = (1«1),  /*  Erroneous source lines */
    liOK    =   (1<<2), /*  Correct source lines */
    liINCL =    (1<<3), /*  Look also in PUSHed files   */
    liHEAD =    (1<<4)  /*  Heading */
}   1mTyp;
typedef enum lmMessages {
lm XXXX_Messages,
} 1mNessages;
Constants
#define 1mSEPARATOR ((char)Oxff)

#define liTINY (liSUMIliERRIliHEADIliINCL) #define liFULL (liTINYIliOK)

#define sevALL (sevOKIsevINFIsevWARIsevERRIseFATIsevSYS)


Functions
void lmLilnit(
char header[], char src[], 1mMessages msect);
void lmLog( %%(srcpType) *pos, int ecode, lmSev sev, char istrs[]);

@PAGE 225 -- ListerMaker Reference Manual

void 1mLogv( %%(srcpType) *pos, int ecode, 1mSev sev,
void lmLiOff(%%(srcpType) *pos); void lmLiOn(%%(srcpType) *pos);
void lmLiEnter( %%(srcpType) *pos, %%(srcpType) *start, char fnm[]);

void lmLiExit(%%(srcpType) *pos);

void lmLiPage( %%(srcpType) *pos, int lins);

lmSev lmSeverity(void); 1mSev lmLocSeverity(void); void lmResLocSeverity(void);

void lmList(
char ofnm[], int lins, int cols, 1mTyp typ, 1mSev sevs);

void lmListm(
char ofnm[], int lins, int cols, lmTyp typ, 1mSev sevs, char *fnms[]);

void lmListsi( char ofnm[], int lins, int cols, 1mTyp typ) ;

void lmLists( 1mSev sevs, int fno, char *fpm);
void lmListse(lmSev sevs);

int lmMsg(
int i, %%(srcpType) *pos, char *msg);

void lmLiPrint(char str[]); void lmSkipLines(int lins);

@PAGE 226 -- ListerMaker Reference Manual

void lmLiTerminate(void);

==================================================
Part V
Toolmake
Reference Manual

@PAGE 229 -- Part V Contents
@PAGE 231 -- Toolmake Reference Manual


@PAGE 232 -- Toolmake Reference Manual

2   PRINCIPLES OF OPERATION
When started toolmake will ask you about the system name and the target language to be used.

Then the command loop is entered which allows you to select or deselect the components you intend to be ToolMaker based. Initially all components are selected. If a component is selected toolmake will generate template or example versions of the files relating to that component.

The command loop also allows the level of information in the generated files to be specified (minimal, normal or a complete example).

Note: When generating without all components the resulting files will not be guaranteed to be compilable without modifications.

Finally the suggestion for a main program and a makefile (or command file) may be selected or deselected.

In the generation phase toolmake produces necessary (explicitly or implicitly requested) description and other files in the current directory by calling the Macro Processor IMP to prepare them from skeleton files in the target language libraries.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 233 -- Toolmake Reference Manual

3   THE TOOLMAKE COMMAND
Toolmake is invoked by the following call:

toolmake [-help] [<option>...] [<system-name>]


3.1 Parameters

Toolmake takes one optional parameter, the subsystem name, this parameter is used as default for a subsequent question about the name. Or, as a matter of fact, as the subsystem name in combination with the -go option.

3.2 Options -[-]go

Do [not] enter the generation phase immediately without starting any command loop (default: off, i.e ask the user first!).

-[-]verbose

Enable [disable] verbose output mode (default: off). Verbose mode will give some information regarding the actions chosen by toolmake.

-help

Gives you a brief but informative help on the arguments and options to the toolmake program.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 234 -- Toolmake Reference Manual

4   TOOLMAKE RUN-TIME USAGE
When using toolmake you will normally go through two phases. First specification, when you decide the subsystems name, target language, parts to use etc. Each of the parts may be selected or deselected simply by typing its name, the contents level is selected by typing level followed by the level required.

The second phase is the generation phase when toolmake (by using IMP) actually creates the proper files in your current directory. In this phase you will only need to interact if any errors or unclarities are discovered. The generation phase is automatically entered by giving an empty specification command (i.e. a carriage return without any input).

Toolmake is built to be robust in interaction with the user (that's you), so you can always get help when asked a question by typing a question mark. These properties in addition to the walk-through in ToolMaker System Description should give you the aid needed.

4.1 Subsystem Name

The initial question when toolmake is started is

Subsystem name?

This question should be answered with the name your new ToolMaker-based system should have. This name will be the basename for all description files, main program template and Makefile-target generated by toolmake.

If the optional argument is used (see section 3.1 on page 233) that is used as the answer for this question and the question is not put.

The specified system name, target language along with the selected components and the contents level is then presented. Then the toolmake prompt appears.

4.2 ToolMake Commands

At the prompt one of the commands listed below may be used. The default command, which is executed if an empty command is entered, is presented within parenthesis. For example

toolmake (GENERATE)>

4.2.1   GENERATE

The generate command will start the generation of the files (components) currently selected. After completed generation toolmake is terminated. If any of the generated files already exists the user is required to confirm overwriting them.

@PAGE 235 -- Toolmake Reference Manual

4.2.2   QUIT

The quit command immediately terminates toolmake, without any generation of files.

4.2.3   ALL

To select all components supported, the all command can be used. To select means that they are candidates for being generated when the generation phase is entered.

4.2.4   NONE

The none command is the opposite of the all command. Le. all components are deselected.

4.2.5   PARSER, SCANNER, LISTER, MAIN, MAKEFILE

These commands all toggle the selection of the corresponding component. Le if the component is selected it will be deselected, and vice versa.

4.2.6   LEVEL

The level command takes one parameter which is one of

* MINIMAL
* NORMAL

EXAMPLE

If the level is not specified in the command, toolmake will prompt for it (together with the default value).

4.2.7   LANGUAGE

The target language to be used in the generated files can be set with the 1 anguage command. It also requires the language as a parameter. Possible languages are

C ANSI-C C++

If the language is not specified in the command toolmake will prompt for it together with the default value in parenthesis.

@PAGE 236 -- Toolmake Reference Manual

4.2.8   VERBOSE

The verbose command toggles the setting of verbose mode. When ON toolmake prints some extra information during generation.

4.2.9   HELP

The command help will list the available commands together with a short description as opposed to the '?' which only lists the command names.
4.2.10 INFORMATION

The information command lists the current setting of the various options, such as selected components, target language and contents level.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 237 -- Toolmake Reference Manual

A   ERROR MESSAGES

The following diagnostic messages may appear when running toolmake. In this list they appear sorted in severity order, with the most severe messages first. Emphasized words in the error messages below are substituted with the actual error information.
A.1 System Errors

System error! malloc: out of memory
A very serious error since toolmake hardly uses any dynamic memory, please contact your systems administrator or your ToolMaker contact person.
System error! function(): switch error (integer)
A very serious software error in toolmake, please contact your ToolMaker contact person.
System error! IMP failed to set variable (error code integer) System error! IMP failed (error level integer)
Internal errors in the communication between toolmake and IMP, please contact your systems administrator or your ToolMaker contact person.
A.2 Fatal Errors

Fatal! Language library not found: language name
The selected language is not yet installed on your system, or the environmental variable TMHOME is not properly set.
Fatal! Illegal function type: function name
An error in the command line parsing, please contact your ToolMaker contact person.
Fatal! Skeleton file halted with error code integer
IMP executed an %%EXIT command in a skeleton file, this should not occur and should be reported to your ToolMaker contact person.
A.3 Errors

Error! File not found: file
Probably the environmental variable TMHOME is not properly set, e.g. the indicated directory can contain an older version of ToolMaker.

@PAGE 238 -- Toolmake Reference Manual

Error! Non-matching option: option
An unknown option was supplied.
Error! License server: unknown error (number)
The license file did not have the correct format. Contact your ToolMaker contact person.
A.4 Warnings

Warning! Argument not used: argument
Too many arguments where supplied.
Warning! File exists: file
This messages informs you that a file to be generated already exists. You are asked a new question about which action to take (quit, rename etc. HELP will give more information).
Warning! License server: no license available
You were not able to get a ToolMaker license as there were too many other simultaneous users. Try again later.
Warning! License server: date expired
Your ToolMaker license has expired. Contact your ToolMaker contact person.
Warning! License server: no contact
ToolMaker was not properly installed or your license server process has died. Contact your ToolMaker contact person or system administrator.
Warning! License server: date expired
Your ToolMaker license has probably expired. Please contact your ToolMaker contact person or system administrator.
Warning! License server: illegal license key
The password in the license file was illegal. Contact your ToolMaker contact person.
Warning! License server: format error
The license file did not have the correct format. Contact your ToolMaker contact person.

@PAGE 239 -- Toolmake Reference Manual

Warning! License server: license file missing
No license file was found in the TMHOME directory. Contact your ToolMaker contact person.
A.5 Informational Messages

Note that informational messages are only printed when the verbose output mode is enabled.

Information! Generating: file
Informational message about the file to be generated.
Information! Backup file: file
If you decide to generate a file although it already exists the old file will be saved with another name.
Information! Execution stopped
The previous error was so severe that toolmake is aborted.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 240 -- Toolmake Reference Manual

B   FILE GENERATION DETAILS

The details in this appendix should be regarded as an internal interface between toolmake and the skeleton files used, compatibility between two versions of ToolMaker is not guaranteed.

The toolmake program is however guaranteed to be available in future versions.
B.1 Generated Files

The files generated differs naturally depending on target language, wanted components and generation level. For the default case and a subsystem called x, the following ToolMaker description files will be generated:

* x.tmk The common ToolMaker description file.
* x.smk The ScannerMaker description file.
* x.pmk The ParserMaker description file.
* x.lmk The ListerMaker description file.

And for your convenience:

* x.c   An example main program.
* Makefile  A suitable file for make(l).

The following source code files will be generated empty by toolmake, to be filled by the various Makers.

* xCommon.h subsystem common definitions, e.g. token definition
* xScSema.c, xScan.c, xScan.h scanner
* xPaSema.c, xParse.c, xParse.h parser
* xList.c, xList.h lister
* xErr.c, xErr.h error handler, an interface between parser and lister

B.2 Skeleton Files

Toolmake uses skeleton files for all the files it produces. The skeleton files are found in the different language libraries found under the ToolMaker directory, $TMHOME/lib (normally /usr/local/ToolMaker/lib/).

@PAGE 241 -- Toolmake Reference Manual

These files are used as input to IMP together with the appropriate settings of all the variables above. The output should be directed to an appropriate output file in the current directory. For example, for a 'ansi-c'-based system with the system name p10:

imp -s T("12:34:56") -s D("1990-01-12") \ -s sN("p10") -s_tL("ansi-c") ... \ $TMHOME/lib/c/main.imp p10.c

For more details on using the Macro Processor IMP refer to the IMP Reference Manual.

The skeleton files for the files produced by toolmake are:

* pmk.imp ParserMaker description file skeleton
* smk.imp ScannerMaker description file skeleton
* lmk.imp ListerMaker description file skeleton
* tmk.imp common description file skeleton
* main.imp main program skeleton
* makefile.imp makefile skeleton
* voc.imp ScannerMaker vocabulary file skeleton

B.3 IMP Variables

Toolmake uses SoftLabs Incremental Macro Processor, IMP, in order to generate the files properly. In each call to IMP, toolmake will set some IMP variables. These are used by the IMP scripts to produce the appropriate file. The following variables are required:

Variable Description (example value)
T   Current time ("23 : 59 : 59 ")
_D  Current date 1999-12-31
_P  Producers name ("toolmake")
_V  Version information (v2, rO, c0)
_sN System name ("pl0")
_Lvl    Contents level, MINIMAL, NORMAL or EXAMPLE (NORMAL) _tOS    Target OS (SunOS)
_tL Target language ("ansi -c " )
_tD Target directory below $TMHOME/lib ("ansi-c ")
_tX Target language file extension (" c ")
_i  Included parts of ToolMaker (sm, pm, 1m, tm)
mm  If main module generated (YES)

If you would do a manual call to IMP in order to produce any of the library files, see below, you must supply these variables. This should however be avoided since this may not be compatible with coming versions of ToolMaker.

==================================================
Index

@PAGE 242 -- Toolmake Reference Manual

@PAGE 245

Symbols
#line 91

A
acceptance cost 73 ambiguous grammar 68

B
BNF 60

C
character class 156 character map 149 character set 142, 148 closure 155 common options 30
relevant for ListerMaker 202
relevant for ParserMaker 87
relevant for ScannerMaker 141 context 164
cut operator 155

D
delete cost 95
description file 25 disambiguating rules 68, 71

E
EBNF 60
embedded semantic actions 67 end of input 157 end of text 157 error correction 72 error message 22 error recovery 72
improvement 94
interface module 108
tuning 75

F
fiducial symbol 74, 75, 98
full list 213

G
global messages 198 grammar attributes 64
in EBNF rules 65 grammar file 77 grammar production 62

H
hook 147

I
IMP 24
include 210,213
Incremental Macro Processor 24 inherited attributes 67 insert cost 95
insert string 199, 218 insertion marker 199, 218 item set 100

L
LALR 23, 68
left recursive grammar 89 lexical attributes 67 Lister 198
ListerMaker 24 listing file 27, 28, 100 listing information 200 listing phases 209

M
Maker 25
Maker prefix 42 markers 28, 199, 218 message
number 198, 219
template 28, 198, 201, 218 message sections 204 metalingustic variables 60 modification rules 71



@PAGE 246

Index
N
nested files 210, 213 non-terminals 60



@PAGE 0

option format
in description files 40
on the command line 40 option precedence 42

P
packing 90, 143
panic mode 75
parse stack overflow 89 parser entry point 107 parser prefix 76 ParserMaker 23 posthook 147 prefix 42, 76, 136 prehook 147

R
reader 146
recovery point 107 reduce-reduce conflict 68 regular expressions 154-158 right recursive grammar 89
scanner 134
scanner context 164 ScannerMaker 24 screening 134, 143
semantic actions 63, 66, 99, 134
embedded 67
severity 199 shift-reduce conflict 68 single symbol correction 73 skeleton files 26, 77, 137 source position 22, 198
source position calculation 135, 166 standard error 214
standard input 146
string synthesising 74 syntax error 72 synthesized attributes 66 system name 234 system prefix 42, 76, 97

T
table packing 90, 143
terminals 60 tiny list 213 token 134
token buffer 144 token type 36 toolmake 24, 29
ToolMaker Common Description
file 26, 100, 160, 204

U
unknown token 158

V
vocabulary 28, 103, 134, 151 vocabulary file 27, 102

