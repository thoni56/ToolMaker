ToolMaker
Reference Manual
Version 2.0
==================================================

@PAGE 54 -- ToolMaker System Description

Part II
ParserMaker
Reference Manual

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 111 -- ParserMaker Reference Manual

A   THE PL/O EXAMPLE
This example is a part of the pl/0 example used throughout the ToolMaker documentation. The ToolMaker System Description contains a detailed walkthrough of the relevant parts of the example. This appendix contains the files relevant for ParserMaker.
A.1 plO.pmk -- The ParserMaker Description File
-------------------------------------------------------
-- plO.pmk  Date: 1993-12-27/toolmake
-- plO -- ParserMaker grammar description file
-------------------------------------------------------Created: 1993-04-27/reibert@roo Generated: 1993-12-27 15:39:38/toolmake v2,rO,c4
-------------------------------------------------------
%%OPTIONS Verbose; %%END

%%IMPORT
#include <stdio.h> #include <strings.h>

#include "plOParse.h"
#include "plOList.h" #include "plOScan.h"
extern plOScContext lexContext;

%%EXPORT
/* Semantic attribute interface

/* Internal node type */ typedef struct Node {
char *string;
int value;
struct Node *next; } Node;

%%DECLARATIONS
/* Counters for the various contructs */
static int constants, variables, procedures, statements;

/* The node constituting the program */ static Node *program;
/*
makeNodeO
Make a new list node and initialize it.
static Node *makeNode(char *string, int value)

@PAGE 112 -- ParserMaker Reference Manual

Node *temp;

temp = (Node *)malloc(sizeof(Node));
temp->string = (char *)malloc(strlen(string) + 1); strcpy(temp->string, string); temp->value = value;
temp->next = NULL;
return temp;
/*
append()

Append two lists of nodes.


static Node *append(Node *listl, Node *list2)

if (listl->next) return append(listl->next, list2); else {
listl->next = list2;
return listl;
/*
summary ( )

Print a summary of the PL/O program using the Lister.
*/
void summary o
)
Node *node; char buf[256];
sprintf(buf, "Number of constants: %u", constants); plOLiPrint(buf);
for (node = program; node; node = node->next) { sprintf(buf," %s = %d", node->string, node->value); plOLiPrint(buf);
plOLiPrint("");
sprintf(buf, "Number of variables: %u", variables); plOLiPrint(buf);
sprintf(buf, "Number of procedures: %u", procedures); plOLiPrint(buf);
sprintf(buf, "Number of statements: %u", statements); plOLiPrint(buf);
%%SCANNER
scan(token);

%%TERMINALS
IDENTIFIER= 2,1,1 => '<id>';
NUMBER  = 3, 1,l => '0';
4;
= 5;

@PAGE 113 -- ParserMaker Reference Manual

    6;
    7;
<'  8;
>'  9;
<>' 10;
    11;
    12;
('  =   13;
    14;
+'  15;
    16;
    17;
~'  18;
    33;
IF' =   34;
DO' 35;
'CALL'  36;
'VAR'   25;
'END'   26;
'ODD'   =   27;
'THEN'  28;
'CONST' =   29;
'BEGIN' =   30;
'WHILE' =   31;
'PROCEDURE'= 32;
INCLUDE = 37;   -- Include is allowed but handled by the scanner
%%ATTRIBUTES
srcp %% TmSrcp %1 %%,
Extra user-defined fields and attributes should be added here
list %% Node* %l %%, stringValue %% char %1[256] %%, integerValue %% int %1 %%;

%%RECOVERY
Fiducial('CONST', 'VAR', 'PROCEDURE', 'CALL', 'BEGIN', 'IF', 'WHILE');
Separator(',',  ;');
%%RULES <program>
<block> '.

program = %<block>.list;
<block>
<declarations> <statement> propagate the constant list

%<block>.list = %<declarations>.list;
<declarations>
<constant declaration> <variable declaration> <procedure declarations>

@PAGE 114 -- ParserMaker Reference Manual

-- propagate the constant list

<declarations>.list =
%<constant declaration>.list;


<constant declaration>
_ 'CONST' <constant definitions> %%
%<constant declaration>.list
%<constant definitions>.list;
%%
! -- Empty

%<constant declaration>.list    NULL;
<constant definitions>
<constant definitions>  <constant definition>

%1<constant definitions>.list = append(%2<constant definitions>.list,
makeNode(%<constant definition>.stringValue,
%<constant definition>.integerValue));

! <constant definition>

%<constant definitions>.list = makeNode(%<constant definition>.stringValue, %<constant definition>.integerValue);
<constant definition> IDENTIFIER '_' NUMBER

constants++;
strcpy(%<constant definition>.stringValue,
%IDENTIFIER.stringValue);

%<constant definition>.integerValue =
%NUMBER.integerValue;
<variable declaration>
VAR' <identifiers> ', ! -- Empty
<identifiers>
_ <identifiers> IDENTIFIER %%
variables++;

! IDENTIFIER variables++; <procedure declarations>

ParserMaker Reference Manual


@PAGE 115

<procedure declarations> <procedure declaration> ! -- Empty
<procedure declaration>
_ 'PROCEDURE' IDENTIFIER

procedures++;
<statement>
* <assignment statement>

statements++;

! <call statement> statements++;

! <compound statement> statements++;

<if statement> statements++;

! <while statement> %%
statements++; %%
Empty


<assignment statement>
- IDENTIFIER '.=' <expression>


<call statement>
* 'CALL' IDENTIFIER
<compound statement>
= 'BEGIN' <statements> 'END'


<statements>
* <statements> <statement> ! <statement>


<if statement>
* 'IF' <condition> 'THEN' <statement>


<while statement>
* 'WHILE' <condition> 'DO' <statement> ;
' <block>
<condition>
'ODD' <expression>
<expression> <relop> <expression>

@PAGE 116 -- ParserMaker Reference Manual

<relop> = _ ! '<>
i
<   !   '>' !   '<=
<expression>
= <optional sign> <terms>
<terms>
<terms> <addop> <term> <term>


<term>
<term> <mulop> <factor> <factor>
<factor>
IDENTIFIER
! NUMBER
!   (' <expression> )
<optional sign> --Note the empty --last alternative!

<addop> = '+' ! <mulop> =

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 117 -- ParserMaker Reference Manual

B   ERROR MESSAGES

Error messages produced by ParserMaker are output to the terminal, and if the
option List Input; is set, also to the list file.
For a description of the format of error messages refer to Message Format in the ToolMaker System Description, page 49.
B.1 Message Explanations

The following list gives a brief summary of the error messages and in some cases the actions that should be taken by the user. Messages with numbers less than 100 are messages common for all Makers. These are described in Messages Explanations in the ToolMaker System Description, page 50. Messages indicating license problems or limitations are described in License Errors in the ToolMaker System Description, page 51.
100 I Parsing resumed.
Issued after a syntax error has resulted in some symbols being deleted.
The sequence number indicates the point from which scanning
and parsing will continue.
101 E %1 inserted.
Syntax error, the recovery method has inserted some symbol(s) in order to be able to continue parsing. The syntax error(s) must be corrected in order for a valid result to be produced.
102 E,F %1 deleted.
Syntax error, the recovery method has deleted some symbol(s) in order to be able to continue parsing. The syntax error(s) must be corrected in order for a valid result to be produced.
103 E %1 replaced by %2.
Syntax error, the recovery method has replaced some symbol(s) in order to be able to continue parsing. The syntax error(s) must be corrected in order for a valid result to be produced.
104 E Syntax error, stack backed up.
Severe syntax error, the recovery method has been forced to pop symbols off the stack in order to be able to continue. The syntax error(s) must be corrected in order for a valid result to be produced.
106 S Parse stack overflow.
The ParserMaker internal parse stack has overflowed. Please save the files that have caused the error and contact your ToolMaker contact person.

@PAGE 118 -- ParserMaker Reference Manual

107 S Parse table error.
Errors have been detected in the ParserMaker internal parse tables. Please save the files that have caused the error and contact your ToolMaker contact person.
108 I Parsing terminated.
Issued when it is impossible for ParserMaker to make any sense of the input. The error messages preceding this message will hopefully give some hint to what is wrong.
113 E Reduction and no-reduction sets intersect. Set = f%1}.
In the indicated production there is both a reduce for and a reducenot-for clause for the indicated symbols. Decide what action you want on the indicated symbols and delete them from the other clause.
114 W Repetition of Null string ignored.
The EBNF-construct for repetition has been used, but it contains no symbols and is thus not necessary. If the offending rule is correct without the repetition, remove the repetition, otherwise correct the rule.
115 E Ambiguous symbol %1 ignored, terminal or non-terminal expected.
A terminal or a non-terminal are the only symbols allowed in this position, and the found symbol was neither.
116 E Ambiguous symbol %1, non-terminal expected.
A non-terminal is the only symbol allowed in this position, and the found symbol was not a non-terminal.
117 E Ambiguous symbol %1, terminal expected.
A terminal is the only symbol allowed in this position, and the found symbol was not a terminal.
118 E Ambiguous symbol %1, attribute expected.
An attribute is the only symbol allowed in this position, and the found symbol was not an attribute.
119 W Attribute %1 defined twice.
The indicated attribute has been multiply defined in the attributes section. Remove all but one definition.
120 E Terminal code %l already in use.
The indicated terminal code has been used for more than one terminal. Each terminal must have a unique terminal code. Note that terminal codes 0 and I are reserved by ParserMaker and must not be used.
TooWake--ion 2.0
ParserMaker Reference Manual


@PAGE 119

121 W Terminal %1 defined twice, old definition overridden.
The indicated terminal has been defined more than once in the terminals section. The last definition is the one used by the system. Remove all but one definition.
123 S Ambiguous symbol %1, terminal expected.
A symbol has been found in the terminals section that ParserMaker thinks is not a terminal. Please save the files that have caused the error and contact your ToolMaker contact person.
130 F End of file in %1.
End of file has been found in a target code section. Truncated file or missing I%%'?
131 F Quoted string in semantic action does not terminate.
A single-quoted string following a'%'-sign (i.e. a ParserMaker symbol) does not terminate. You have probably forgotten the ending quote, and thus the rest of the semantic action has been skipped.
148 E Repetition construct contains only modifiers or semantic actions.
The EBNF repetition construct has been used in a production, but it contains no grammar symbols and is thus meaningless. Remove the repetition construct or correct the rule.
149 E Symbol not recognized in production.
The indicated grammar symbol used in the attribute reference does not occur in the production and is thus erroneous. Misspelling or an attempt to use attribute references in semantic actions embedded in a production (this is not allowed, see Grammar Attributes on page 64 for further details).
150 E Undefined attribute %1.
The indicated attribute has not been defined in the attributes section. Misspelling?
151 E Reference to outer EBNF construct is not possible.
An attribute to an outer EBNF (OEBNF) construct has been made, but no outer EBNF construct exists in this context, so a reference is not possible.
152 E Attribute %1 must be non-terminal or vocabulary attribute.
A reference to a terminal attribute has been made, but for this symbol only non-terminal or predefined attributes are allowed.

@PAGE 120 -- ParserMaker Reference Manual

153 E Wrong instance in attribute reference (OEBNF), first instance assumed.
The indicated instance of the outer EBNF symbol does not exist in this context.
155 E %1 expected.
The indicated symbol is not allowed in this context, instead the symbol given in the error message is expected.
156 E EBNF expression instance not recognized in production.
The indicated instance of the outer EBNF (OEBNF) symbol does not exist in this context.
158 E Attribute class in conflict with symbol type.
A terminal attribute has been referenced for a non-terminal or vice versa.
159 E Symbol instance not recognized in production.
The indicated instance of the grammar symbol does not exist in this context.
166 E You are not allowed to use both the %1 and the PACK directives.
The packing of tables are selected either using the Pack directive which influences the packing of both the action and goto tables simultaneously, or using the Actionpack and Gotopack directives which influences the packing separately. If you have specified Acti onpack you must use Gotopack if you want to specify the packing of the goto tables.
196 F Cannot allocate memory for hash table.
197 F Cannot allocate memory for entry in vocabulary table. 201 F Cannot allocate memory for production data structure. 204 F Cannot allocate memory for nodes to build syntax tree. 205 F Cannot allocate memory for modification data structure.
206 F Cannot allocate memory for attribute reference data structure.
207 F Cannot allocate memory for semantic actions table.
208 F Cannot allocate memory for attribute storage structure.
209 F Cannot allocate memory for strings to generate non terminal.
213 F Cannot allocate memory for sorting grammar.
214 F Cannot allocate memory for strings to make error message.
Failure to allocate memory for the indicated data structure. Contact your system administrator for advice on how to obtain more memory.

@PAGE 121 -- ParserMaker Reference Manual

215 S Production queue is empty.
The ParserMaker internal production processing queue has been emptied abnormally. Please save the files that have caused the error and contact your ToolMaker contact person.
230 W %1 given in the TERMINALS SECTION but never used in grammar.
A terminal has been explicitly given in the terminals section, but it does not appear in any production, so it is ignored. Misspelling?
231 I %1 was not included in the TERMINALS SECTION.
The indicated terminal has been used in the grammar, without being defined in the terminals section. Since this is perfectly legal, and sometimes desirable, one way to get rid of this message is to specify the directive List without the info option.
232 W More than one goal symbol found, %1 used.
More than one non-terminal fulfils the conditions for being chosen as goal symbol, so the grammar is probably erroneous. Misspelling? Remember that symbols are case sensitive!
233 W No explicit goal symbol found, %l used.
No non-terminal fulfils the condition that it should never appear in any right hand side, so the indicated non-terminal (the left hand side of the first production) is chosen by ParserMaker as the goal symbol. If your goal symbol appears on the right hand side of at least one production, make sure that a rule deriving your goal symbol is the first production of the grammar!
234 E Grammar is non terminating, symbol %1.
The grammar has infinite recursion, e.g. the definition of symbol X includes X in all its right hand sides:
X = X Y Z
! T X V
Note that the symbol printed in the error message is not necessarily the offending symbol, instead it is the top symbol in the infinite derivation tree. Thus all symbols that can be derived from the printed symbol in one or more steps should be checked!
235 E Section already defined.
You may only specify the various sections once in the description file.
236 E No sections allowed after %%RULES-section.
The rules section must be the last section in the description file.

@PAGE 122 -- ParserMaker Reference Manual

237 W %%INSERTSYMBOL and/or %%DELETESYMBOL sections used

although errorhandler generation turned off.
One or both of the inserts ymbol and deletesymbol sections where present in the description file. The option 'No Errorhandler; ' was also used to turn the generation of an errorhandler off. This means that the target code in the sections will not be used.
301 W Conflicts resolved by default rules.
Default rules have been used to resolve LALR(1) conflicts. The list file contains details about the changes that have been made.
302 W Conflicts resolved by modifications.
Modifications have been used to resolve ambiguities. The log file contains information about the effects.
303 E Grammar is not LALR(l).
The grammar is ambiguous, and the default disambiguating rules and/ or the supplied modifications were not sufficient to disambiguate the grammar. Inspect the log file (see Format of the Generated Item Set on page 100) and modify the grammar. If the grammar is hard to make LALR(l), try using more disambiguating rules.
401 F Description file "%l" not found.
The indicated description file could not be found. Some possible causes:

* You misspelled the file name.
* You are in the wrong directory.
* You did not take into account that pmk is added to files without any extension.

402 F Could not open list file "%l".
403 F Could not open table file "%l"_
404 F Could not open vocabulary file "%1".
The indicated output file could not be opened. The most probable cause is that you do not have write permission on the directory or that the file already existed and is write protected.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 123 -- ParserMaker Reference Manual

C   DESCRIPTION LANGUAGE

This appendix contains a syntax summary of the ParserMaker description language. For a full discussion of the language, see The ParserMaker Description File on page 79.
For a brief discussion of the notation used in this description see appendix C in the ToolMaker System Description, SYNTAX NOTATION, page 52.
Language Syntax
<description file> :._
[ <toolmaker sections> ] ( <other sections> ] <rules section>

<toolmaker sections>
[ <options section> ]
{ <import section> I <srcp section>
<token section> ]
<other sections> :._
{ <declarations section> <terminals section> <attributes section> <recovery section> <export section> <scanner section> <insertsymbol section> <deletesymbol section> ]

<options section>   _
['%%OPTIONS' <directive> (<directive>) ['%%END']]

<directive> .._
<common directive> <listerprefix directive> <errorhandler directive> <trace directive> <lookaheadmax directive> <shiftcost directive> <stacklimit directive> <pack directive> <list directive> <optimize directive> <recovery directive> <resolve directive> <vocabulary directive> <table file directive> <list file directive>

<common directive> : _ <target directive> <os directive> <prefix directive> <library directive> <escape directive> <width directive> <height directive>
C.1

@PAGE 124 -- ParserMaker Reference Manual

<generate directive> <force directive>
<listerprefix directive> :._ 'LISTERPREFIX' <quoted string>

<errorhandler directive> :._ ['NO'] 'ERRORHANFLER' ',

<trace directive> :._ ['NO'] 'TRACE'

<lookaheadmax directive> ::= 'LOOKAHEADMAX' <number>

<shiftcost directive> :._ 'SHIFTCOST' <number>

<stacksize directive> ::=
'STACKLIMIT'        <number> ',
<pack directive>        ::=
'PACK'      <pack option>
        f',' <pack option>} ',
    ['NO']      'PACK'
        'ACTIONPACK'    <pack option>   ',
            (',' <pack option>}
    'GOTOPACK'  <pack option>   ,
        (', <pack option>}
<pack option> :._
'ROW'   'COLUMN' I 'RDS'
'GCS'   'LES' I 'ERROR' <list directive> :._
'LIST' <list option>
f'  <list option>}
['NO'] 'LIST'

<list option> ::=
'INPUT' I 'GRAMMAR' I 'ITEMS'
I 'TABLES' I 'STATISTICS' I 'INFO'

<optimize directive> --
'OPTIMIZE' [<optimize option>
f',' <optimize option>)] ['NO'] 'OPTIMIZE' ',

<optimize option>   'LRO'

<recovery directive> .--
'RECOVERY' [<error option>
(',' <error option>}] ',
I ['NO'] 'RECOVERY' ',
<error option> ._
'SINGLE' I 'MULTIPLE' I 'PANIC'

<resolve directive> :-
'RESOLVE' <resolve option>
('  <resolve option>) ['NO'] 'RESOLVE' ',

@PAGE 125 -- ParserMaker Reference Manual

<resolve option> :._ 'SR' I 'RR'

<import section> :._
'%%IMPORT' <target language code> ['%%END']

<export section> :._
'%%EXPORT' <target language code> ['%%END']

<declarations section> :._
'%%DECLARATIONS' <target language code> ['%%END']

<terminals section> :._
'%%TERMINALS' (<terminal definition> ['%%END']

<terminal definition> ::
TERMINAL '_' <token code> [<error recovery data>]

<token code>    <number>

<error recovery data> ::
1,1 <insert cost> ',' <delete cost> [<print symbol>]
<insert cost> <number> <delete cost> <number> <print symbol> :._ '=>' TERMINAL

<attributes section> :._
'%%ATTRIBUTES'
<grammar attribute> {',' <grammar attribute>} ', ['%%END']

<grammar attribute> ::=
<identifier> [ '%%' <target language code>

<scanner section> :._
'%%SCANNER' <target language code> ['%%END']

<insertsymbol section> :._
'%%INSERTSYMBOL' <target language code> ['%%END']

<deletesymbol section> :._
'%%DELETESYMBOL' <target language code> ['%%END']

<recovery section> :._ '%%RECOVERY' [<meta part>] [<separator part>] [<fiducial part>] [<skip part>] ['%%END']

<meta part> :._
'META' (<mete name> '(' TERMINAL
{',' TERMINAL)  TERMINAL] ';'}
<separator part> :.= 'SEPARATOR' '(' TERMINAL
TERMINAL}
')  ,

@PAGE 126 -- ParserMaker Reference Manual

<fiducial part> :._
'FIDUCIAL' '(' TERMINAL {',' TERMINAL)
')'
<skip part> :._
'SKIP' '(' TERMINAL {',' TERMINAL)

<rules section>
'%%RULES'
{NONTERMINAL '=' <alternatives> ['%%END']

<alternatives> :._
<right hand side> {'!' <right hand side>)

<right hand side> :._ <components> <opt modify> <components>    {<component>}

<component> .._ <symbol>
<action modify> '(' <components>
{ <components>
[' <components>

<symbol>    TERMINAL
<action modify> :._
<opt modify> <semantic action> <opt modify>

<semantic action> ::
'W <any character sequence, but %%> '%%'

<opt modify> ::
(('%" I '%-') '(' TERMINAL {',' TERMINAL}
<components>) ')' NONTERMINAL
C.2 Lexical Items
TERMINAL :._
<identifier>
<angle bracketed string> <quoted string>

NONTERMINAL :.=
<identifier>
I <angle bracketed string> ATTRIBUTE :._
<identifier>

<identifier> .._
<letter> {<letter> I <digit>    }

<string> .._
<quoted string>
<angle bracketed string>

<quoted string> ::
'' ' <character> {<character>}

<angle bracketed string> :._ :characters {:character-)

@PAGE 127 -- ParserMaker Reference Manual

<number>    <decimal integer> I <hexadecimal integer>
<decimal integer>   <digit> {<digit>}
<hexadecimal integer>   '#' <hex digit> {<hex digit>)
<letter> .._
<upper case letter> I <lower case letter>

<special character> :._
<hex digit> <digit>
'A' ,B,

'a' 'b'
'C' 'c'
'D' 'd'
'e'
&,  ,{, ,}'
F' 'f'

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 128 -- ParserMaker Reference Manual

D   TARGET LANGUAGE DETAILS
In the descriptions below, the IMP insert statements %% (tokenType) and %% (codeType) refers to the type names defined by the token section (see The Token Section in the ToolMaker System Description, page 36).
D.1 'c'
void pmParse();

void pmRPoi(token) %%(tokenType) *token;

void pmlSym(code, symString, printString, token) %%(codeType) code;
char *symString; char *printString; %%(tokenType) *token;

void pmDSym(token, symString) %%(tokenType) *token; char *symString;

void pmMess(token, method, code, severity) %%(tokenType) *token; int method;
int code;
int severity;


D.2 'ansi-c' and 'c++'
void pmParse();

void pmRPoi(%%(tokenType) *token);

void pmlSym(%%(codeType) code,
char *symString, char *printString, %%(tokenType) *token);

void pmDSym(%%(tokenType) *token, char *symString);
void pmMess(%%(tokenType) *token, int method, int code, int severity);

==================================================
Part III
ScannerMaker
Reference Manual

@PAGE 131 -- Part III Contents
@PAGE 133 -- ScannerMaker Reference Manual

@PAGE 134 -- ScannerMaker Reference Manual

2   CONCEPTS AND ASSUMPTIONS
2.1 ScannerMaker and Scanner

ScannerMaker is a program which takes a formal description of a set of vocabularies and scanners and then produces a fully usable scanner.

2.2 Vocabulary

ToolMaker introduces the concept of vocabulary. A vocabulary is a set of tokens with a defined external code. In ToolMaker a vocabulary is described in a vocabulary file. ScannerMaker uses this concept to partition a scanner description file into vocabularies. These are further partitioned in scanners and those into rules or skip tokens.
2.3 Token

A vocabulary is a set of tokens. A token is identified by a name or a string and each token has an associated unique number, an external token code. This code is used to report which token was found.
2.4 Scanner

The collection of rules which is used to identify one or more tokens in a stream of characters, strings, files, etc., is called a scanner. A scanner also defines semantic actions to be taken when a rule which matches a part of the character stream is found, this may include manipulating or copying the characters that constitutes the token.


2.5 Scanner and Inheritance

Scanners can use rules which is defined in another scanner by inheriting them, thus creating extensions of scanners without explicitly copying definitions.
2.6 Screening

Screening is a concept which is used to minimize the tables used to implement the scanners. This optimization of space has, as usual, the drawback of generating slower code. Another aspect of screening is the possibility to turn on and off recognition of screened tokens. A token which is used to find a screened token is said to screen the token. A scanner which includes rules which screens a token is said to screen tokens. Tokens and scanners which screens a token may also be turned on or off at run-time.
TnoIM,ker version 2.0


@PAGE 135 -- ScannerMaker Reference Manual

2.7 Token and Source Position Definitions

The generated scanner supports automatic source position calculation. The row, column and position source position members are automatically updated by the generated scanner if they are defined in the source position section is the ToolMaker Common Description file (.tmk). See The Token Section on page 36 and The Srcp Section in the ToolMaker System Description, page 34.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 136 -- ScannerMaker Reference Manual

3   SCANNER PRODUCTION

ScannerMaker requires a number of files to describe the scanner that should be generated. In this chapter descriptions of these files are given.
3.1 Creating a Running Scanner

The figure below gives an overview over the relation between the files required and produced by ScannerMaker. The system prefix sm is chosen by the scanner implementor, and the file names for any produced target source code module is target language dependent.

[IMAGE]

Fig. 2  Files used and produced by ScannerMaker.

@PAGE 137 -- ScannerMaker Reference Manual

Depending on the target language used the produced target language module, sn6can, may be one or more files, e.g. for 'c' there will be one srScan.c and one smScan.h created.

The only files that must be maintained by the user are smsmk and smtmk. A vocabulary file is not necessary though it is strongly recommended that a vocabulary file is used.

The following walk-through should give you a feeling how to create an operational scanner, step by step.

1) Create a ToolMaker description file (smtmk) according to the specifications in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30. This step is not necessary if you are developing a stand-alone scanner (in this case the information can be put inside smsmk instead).

2)  Create a ScannerMaker description file (smsmk) according to the specifications in The ScannerMaker Description File on page 138.

3)  Either run make and skip to step 6, or run smk, ScannerMaker, with smsmk as argument. ScannerMaker can be controlled by using various options as described in THE SCANNERMAKER COMMAND on page 162.

4) Compile the ScannerMaker generated source module, smScan, the scanner semantic actions module sn&Sema, and the common definition module smCommon. If the target language was 'c', smScan.c, smScan.h, smScSema.c and smCommon.h were produced.

5)  Compile and link the main program and any auxiliary modules with the object files produced.

6)  Execute and test the scanner.

Points 1 and 2 can be simplified by invoking toolmake to set up a development environment for you (see the Toolmake Reference Manual). The files created by toolmake must be modified to suit your requirements.
Note: In rare cases the description files are not sufficient to capture all the target dependencies or special requirements for a project, and you have to modify the scanner skeletons. If this is the case copy the file Scan.imp to the development directory from the appropriate library and modify them. TO DO THIS IT IS ABSOLUTELY NECESSARY THAT YOU HAVE A THOROUGH UNDERSTANDING OF THE SYSTEM. Change the library option in the ScannerMaker description file to point to the directory where the modified skeletons resides. When ScannerMaker is executed, it will use these skeletons instead of the standard ones.

@PAGE 138 -- ScannerMaker Reference Manual

3.1.1   File Descriptions

3.1.1.1 Input Files

ScannerMaker description file (.smk). This file describes the scanners which should be generated using the ScannerMaker program, smk. This file is described in The ScannerMaker Description File on page 138.
ToolMaker description file (.tmk). This file describe common definition for all tools in ToolMaker. ScannerMaker uses the token and source position, options, etc., as described in this file.
Vocabulary file, (.voc). This file describes the vocabularies to be used by the scanner. The vocabulary file is normally produced by ParserMaker. This file is described in The Vocabulary file on page 160.

3.1.1.2 Output Files

ScannerMaker source module, (sniScan). This module describes the interface to and implements the scanner.
ScannerMaker semantic action module, (smScSema). This module implements the actions specified in the description file.
ScannerMaker table file, (.smt). This intermediate file is normally not kept after successful source generation. It controls the generation of the files above from skeleton files.

3.2 The ScannerMaker Description File

This section describes the ScannerMaker description file. In this description a modified BNF notation is used to describe the syntax. This notation is briefly described in appendix C in the ToolMaker System Description, SYNTAX NOTATION, page 52.

3.2.1   Lexical items

Symbols in the ScannerMaker description language are constructed from using upper case letters from the ISO-8859-1 character set, lower case letters (ISO-8859-1) and digits.
<letter> :._
<upper case letter> I <lower case letter>
<digit> ..
'2' '3' '4'
I   '5' '6' '7' '8' '9'
<special character> :._


@PAGE 139 -- ScannerMaker Reference Manual

<target code> :._
<any characters in the target language except '%%'>

<token name> :._
<letter> (<letter> I <digit>    _')

<definition name> .._
<letter> (<letter> I <digit>

<string> ::
''I (<letter> I <digit> I <special character>}


3.2.2   Overall Structure

The overall structure of the Scanner Description file is as follows:

<description file> :._
<toolmaker sections> {<target code section>) {<set definition section>} {<general definition section>) (<vocabulary section>)
The toolmaker sections are further described in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30.
<toolmaker sections> :._
[ <options section> ]
{ <import section>  <srcp section>
I <token section> }
The option section follows the general guidelines as described in The Options Section in the ToolMaker System Description, page 30. The options which can be specified in the options section are described in Options on page 162. The import, srcp and token sections are described in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30.
The target code sections are one of the following subsections:
<target code section>   _ <declaration section> <context section> <export section> <reader section> <prehook section> <posthook section> <action section>
The general definition sections are one of the following subsections:
<general definition section> :._ <map definition section> <definition section>
The vocabulary sections have the following structure:

@PAGE 140 -- ScannerMaker Reference Manual

<vocabulary section> :._
'%%VOCABULARY' <vocabulary name>
{ <token name> '=' <external token code> { <scanner section> }
The scanner sections have the following structure:
<scanner section> ::=
'%%SCANNER' <scanner name>  <scanner name>] [ <screened token section> ] [ <undefine token section> ] { <rule definition section> }

The rule section includes the following subsections:

<rule definition section> :._ <rules section> <skip section>

Each section maybe optionally ended by the ' % %END' keyword. The case of the letters in keywords are not significant and all keywords starting with ' %%' may be specified in plural as well as in singular. For example the following keywords are equivalent

%%OPTION
%%Option
%%Options

Between sections, that is, after an ' %%END' token up to the next '%% ' characters, is treated as comments. The special ' %%COMMENT' keyword also starts a comment up to ' %%' . The ' %%' may be quoted by the escape character to be part of the comment. Inside a section comments may appear anywhere as long as they do not break a lexical unit such as an identifier or a string. Comments begin with two hyphens and end with a new line.

3.2.3 The Options Section

-- This is a comment
'%%OPTIONS' {<directive>} ['%%END']

<directive> ::=
<common directive> <optimize directive> <trace direvtive> <set directive> <pack directive> <screening directive> <list directive> <token size directive> <token limit directive> <exclude character directive>
In this section options can be specified to control some actions taken by the scanner generator. These options can be overridden by options given on the command line when the scanner generator is invoked (see THE SCANNER


@PAGE 141 -- ScannerMaker Reference Manual

MAKER COMMAND on page 162). If an option is not specified its default value is used. The default options are:
No Verbose;
Target 'ansi-c'; Os 'SunOS'; Prefix 'sm';
Library '$TMHOME/lib/ansi-c'; Escape ...
Width 78; Height 60; Generate source; No Force; Optimize; No Trace;
Set 'ISO8859_1'; Pack row, column; No Screening; No List;
Tokensize 1024; Tokenlimit 524288;
Note however that the settings of common options in the ToolMaker Common Description file influences the default values (see The Options Section in the ToolMaker System Description, page 30).


3.2.3.1 Common Directives

<common directive> : _ <target directive> <os directive> <prefix directive> <library directive> <escape directive> <width directive> <height directive> <generate directive> <force directive>
The common directives are directives available for all of the Makers in the ToolMaker kit. For a detailed description of these refer to The Options Section in the ToolMaker System Description, page 30. All directives are available for ScannerMaker, and if used overrides settings and default values from the ToolMaker Common Description file.


The prefix directive does not inherit its default value, instead it defaults to
' sm' if not explicitly set in the .tmk file. If set in the ToolMaker Common Description file and not used in the ScannerMaker Description file it defaults to the system prefix (the value set in the ToolMaker Common Description file).

3.2.3.2 The Optimize Directive

<optimize directive> :._ ['NO'] 'OPTIMIZE' ',

@PAGE 142 -- ScannerMaker Reference Manual

This option specifies if the state table should be minimized or not. The generated unoptimized state table is very small as it is, although not always minimal. The default setting is

Optimize;

3.2.3.3 The Trace Directive

<trace directive> :._ ['NO'] 'TRACE'

This option turns on [off] generation of tracing of tokens found by the generated scanner. The default for the trace directive is

No Trace;

3.2.3.4 The Set Directive

<set directive> :._ 'SET' <set name> ',

This option specifies which character set to be used. Predefined sets are

'iso8859_I'Defines a full 8bit characters set to be used.
'ascii' Defines only a 7bit character set.
'ebcdic'    Defines the EBCDIC character set as defined by the UNIX dd
command with ebcdic conversion.
'ibm'   Defines the EBCDIC characters set as defined by the UNIX dd
command with ibm conversion.

Other character sets can be defined by one or more set sections. The default set directive is

Set 'IS08859_1';

3.2.3.5 The Pack Directive

<pack directive> :_
'NO' 'PACK'
'PACK' <pack> {',   <pack>} ,

This option specifies which packing schemes should be used to reduce the size of the state table. The following <pack> schemes are supported:

ROW merge equivalent rows (states) COLUMN merge equivalent columns (characters)
RDS optimized row displacement scheme
LES line elimination scheme
GCS graphic coloring scheme
ERROR   pack error state table generated by LES or GCS by merging equivalent rows and columns

The default packing is

@PAGE 143 -- ScannerMaker Reference Manual

Pack row, column;

Each packing scheme may be combined freely with any other packing scheme with the only exception of ERROR which only has significance together with GCS or LES packing schemes. For example:

PACK LES, RDS, COLUMN;

instructs ScannerMaker to first locate equivalent columns in the state table and merge them. Thereafter a line elimination scheme is used to further reduce the size of the packed table and finally row displacement is used to minimize the table still further.

The order in which the packing is performed is 1)   ROW and/or COLUMN 2)    LES

3)  GCS

4)  RDS

Which packing scheme to use depends on if speed or space requirements is of greatest importance. The same packing scheme may pack some state tables better than other tables. Generally, the best packing schemes are ROW and COLUMN, or RDS, while LES and GCS often gives a good result but are rather slow mainly because of the need of an error state table.

If LES is used it is recommended that GCS is also used because the use of GCS does not affect the speed. The use of RDS is also recommended when LES and/or GCS is used to further enhance packing without greatly affecting the execution speed. However, if speed is essential no packing at all, ROW or COLUMN packing or RDS packing should be used.

3.2.3.6 The Screening directive

<screening directive> :._
NO' 'SCREENING' ',
I 'SCREENING' <minimum token size> ',

Screening is used to reduce the size of the generated scanners. Screening removes the need for all special states for rules which is defined as a sequence of characters, a stream of characters, with a specified minimum length and for which there is another rule which accepts the same token. The rule which is removed defines a screened token and the more general rule which accepts the same token is said to screen a screened token.

When a token which screens another token is found a look-up is performed to check if there is a screened token which is equal to the token found. For example:

@PAGE 144 -- ScannerMaker Reference Manual

%%RULE
'BEGIN' = 'BEGIN'; Keyword = [A-Za-z]+;

In the example above the token 'BEGIN' has a same accept state that hides the Keyword definition. When screening is used the ' BEGIN' token is removed from the resulting DFA and when Keyword is found by the generated scanner it is compared against the string ' BEGIN' and if it matches this token is selected instead of Keyword.

Screening can be enabled for single tokens individually in the screening section. By default all tokens may be screened. To actually use screening the screening option must be specified. The default is to not use screening

No Screening;

3.2.3.7 The List Directive

<list directive>
'NO' 'LIST' '
'LIST' <list> f',   <list>)

This option specifies what should be written into the list file. The following < 1 i s t> options are supported:

INPUT   description file
SET character set
MAP character map used by the generated scanner TOKEN   defined tokens
DFA the state table
NFA the NFA
RULE    the rules defined for each scanner

The list file has the same name as the description file but with any extension replaced by sml. The default is

No List;

3.2.3.8 The Token Size Directive

<token directive>   _
'TOKENSIZE' <minimal token size> ',

The normal or minimal size of the buffer used when scanning. The default setting is

Tokensize 1024;

It should be set so that most tokens will fit inside this limit, however if exceeded the token buffer will be automatically extended gradually to a maximal limit (see the TokenLimi t directive below).

@PAGE 145 -- ScannerMaker Reference Manual

3.2.3.9 The Token Limit Directive

<token directive> :._
'TOKENLIMIT' <maximal token size> ',

The token scanned may not be larger than the specified maximal token length. By the default this is set to

Tokenlimit 524288;

3.2.3.10    The Exclude Character Directive

<exclude character directive> ::= 'EXCLUDE' <exclude character> ',

This option specifies a character excluded from the normal character set. The specified character may never occur in the input and can be used for special purposes by ScannerMaker to create an even more efficient scanner. The default is

No Exclude;

I.e not to exclude any character from the selected character set.

3.2.4   The Declaration Section

<declaration section> :._
'%%DECLARATION' <target language code> ['%%END']

In this section types, variables and functions used within the scanner should be defined. This target language dependent source code is copied into the generated scanner and is accessible (valid) in all other target language sections.

3.2.5   The Context Section

<context section> ::=
'%%CONTEXT' <target language code> ['%%END']

In this section variables used within a scanner context should be defined, see Semantic Actions on page 158 and Type: smScContext and smScContextitem on page 164 for a complete description of how to use the scanner context.

3.2.6   The Export Section

<export section> :._
'%%EXPORT' <target language code> ['%%END']

User defined functions and variables that should be visible outside the generated scanner should be defined in this section, this section is included in the interface description of the generated scanner (in 'c' the smScan.h file).

@PAGE 146 -- ScannerMaker Reference Manual

3.2.7   The Reader Section

<reader section> :._
'%%READER' <target language code> ['%%END']

The code specified in the reader section is executed when reading characters into the input stream, see Semantic Actions on page 158 for more information on the contents of this section. The reader section may be viewed as the body of a function with the following definition.
length = smScReader(smThis,smBuffer,smLength)
smThis  : IN smContext
smBuffer    OUT STRING
smLength    IN INTEGER

The function must return the number of characters read. If no more characters can be read, zero should be returned. In case of an error, a negative value should be returned. This will cause the scanner to abort and return the value as an error code instead of an external token code. For example

%%CONTEXT
int fd;
%%READER
return read(smThis->fd,smBuffer,smLength); %%END

This reader reads from the file fd into the buffer smBuf fer a maximal of smLength characters. It returns the number of characters read or -1 if an error occurs (which will abort the scanner as described above). The default reader is

%%READER
return read(O,smBuffer,smLength); %%END

That is, characters are read from standard input.

3.2.8   The Action Section

<action section> :._
'%%ACTION' <target language code> ['%%END']

The code specified in the action section is executed just before entering any token specific action and is therefore common to all token specific actions, see Semantic Actions on page 158 for a complete definition of semantic actions. This code is copied in-line into the body of the smScAction function and then followed by the semantic actions for the tokens.
code = smScAction(smThis, smInternalCode, smToken)
smThis  : IN smScContext smToken : IN OUT %%(tokenType) returns INTEGER

@PAGE 147 -- ScannerMaker Reference Manual

3.2.9   The Prehook Section

<prehook section> :._
'%%PREHOOK' <target language code> ['%%END']

In the prehook section code which should be performed before scanning a token is defined. For more information on the contents of this section, see Semantic Actions on page 158. The prehook section may be viewed as the body of a function with the following definition

code = smScPreHook(smThis,smToken)
smThis  IN smScContext
smToken IN OUT %%(tokenType) returns INTEGER

If a positive number, zero included, is returned the scanning is terminated immediately. The number is used as the external token code returned by the scanner.

Note: When executing the prehook the variable srnLength has the value 0 (zero).

3.2.10  The Posthook Section

<posthook section> :._
'%%POSTHOOK' <target language code> ['%%END']

The code specified in the posthook section is executed after a complete token is found, see Semantic Actions on page 158 for more information on the contents of this section. The posthook section may be viewed as the body of a function with the following definition:

code = smScPostHook(smThis,smToken)
smThis  : IN smScContext
smToken IN OUT %%(tokenType) returns INTEGER

The found token's external code is determined by the value of the field smCode in the token structure (smToken->smCode in 'c') when the posthook function is terminated. This field is initially set to the value as specified in the vocabulary file or the vocabulary section depending on the token recognised.

The external token code for the token found can be changed in two ways, either by setting smToken->smCode to the new external code or by returning the new external code by executing a return statement. The external token code should be one of the enumeration values defined for tokens in the vocabulary to which the current token belongs, or the predefined enumeration smSkipToken.

When smSkipToken is returned the current token is skipped, as if it was given in the skip section.

@PAGE 148 -- ScannerMaker Reference Manual

Note: It is not possible to specify that the scanning of tokens should be continued within the posthook section.

3.2.11  The Set Section

<set section> ..
'%%SET' <set name> (<set>} ['%%END']

This section defines a character set. The use of a character set is primarily to generate a scanner that should execute on a machine with a different character representation than the machine on which is was generated. A character set may be viewed as the mapping from the native set (the set on the machine which the scanner is running) to the internal for which the tables are generated. This makes it very easy to generate scanners that can be compiled and run on various machines even with different character sets.
The name of the set is specified followed by 256 character specifications. Allowed representation of characters are all non-white printable ISO-8859-1 characters, two digit hexadecimal numbers and the special character combination two dots. The two dots specifies an undefined character. Comments are the same as for the rest of the scanner, double hyphens.
The mapping determines which character is used in the rules description for the n-th character in the character set. For example,
a b .. OF
specifies that the first four characters in the set is a, b, undefined and O F. That is, if the character a is used in the description of the scanner, the generated scanner uses a as the first character in the set (value 97). For example:

%%SET IBMSET
__0 1   2   3   4   5   6   7   8   9   A   B   C   D   E   F ---------------------------------------------------------------------
00  01  02  03      09  ..  7F      OB  OC  OD  OE  OF  0
10  11  12  13      ..  08  ..  18  19              ..  1
        iC  ..      OA  17  1B              05  06  07  2
                        ..  04          14  15      16  3
20                                      <   (           4
&                                   $       l           5
                                        %               6
                                        @               7
..  a   b   c   d   e   f   g   h                       8
        k   1   m   n   o   p   q   r                   9
        S   t   u   V   w   x   y   z                   A
                                                        B
    A   B   C   D   E   F   G   H   I                   C
}   J   K   L   M   N   0   P   Q   R                   D
\       S   T   U   V   W   X   Y   Z                   E
0   1   2   3   4   5   6   7   8   9                   --F

defines a set of a possible IBM character set.

Undefined characters always result in error states in the generated DFA. That is, if such a character is encountered in the input string when the generated

@PAGE 149 -- ScannerMaker Reference Manual

scanner is used, the scanning is aborted and eventually the character is returned as an undefined token.

Any number of character sets can be defined in addition to the built-in allowing easy generation of the same scanner for different character sets.

3.2.12  The Map Section

<map section> .._
'%%MAP' {<character map>} ['%%END']
<character map> :._
<character class>   <character class> ',

This section defines the mapping of a character read in the scanner. This can for example be used to map lower case characters on the upper case, creating a case-insensitive scanner (as opposed to character sets which handle the complete representation of characters and should be changed by changing the setting of the set option).

To define a character map character classes are used. Characters are given on the left-hand side and the equivalent characters on the right-hand side. For example:

[0-9] _ [\xFO-\xF9];

maps the digits to the characters with hexadecimal values FO and F9.

The characters in the character class are ordered from the lowest to the highest character value. The mapping is then performed by assigning the lowest character on the left-hand side to the value of the character on the right-hand side, and so on until the highest value is reached.

If the set of characters on the right-hand side contains fewer characters than that on the left-hand side the highest value of the set with the least number of characters is assigned to the remaining characters of the left-hand side. For example:

[0-9] _ \x0;

maps all digits to the hexadecimal value 0 (zero).

If the left-hand side has fewer characters than the right-hand side the remaining characters are discarded. For example:

[0-9] _ [A-Z];

maps all digits to the ASCII values A to J respectively.

If the character class begins with a character that is greater than the last character in the specified set of characters, the characters are processed in reversed order. For example:

@PAGE 150 -- ScannerMaker Reference Manual

[a-z] = [Z-A];
[9-01 = [\000-\011];

maps the character a to z to the ASCII values z down to A and the digits 0 to 9 to the values 9 (11 octal) down to 0.

The mapping of the empty character set defines undefined values in the character set. It is recommended that the first mapping is to make all characters undefined.
This will disallow the use of any non mapped character. By default all characters are mapped to themselves. That is, the character A is mapped to the character A, etc.

The mapping of characters are given in the same manner as for the mapping of a character set. The only difference is that if characters are mapped to the empty set, those characters are skipped by the scanner. However the characters remain in the token string. This is especially significant when defining a scanner for languages such as FORTRAN where all blank characters are discarded in the input stream.

3.2.13  The Definition Section

<definition section> ::=
'%%DEFINITION' (<definition>) ['%%END']
<definition> ._
<definition name>   [<selection rule>] [<action>]

This section defines identifiers which can be used within regular expressions and/or a semantic action. These definitions can have the same name as a token defined in the rule definition sections. The name of a definition can not be given as a string (i.e. surrounded by quotes).

The definition is defined by using a regular expression in the same way as in the rule definition sections, except that no lookahead definition is allowed. A definition can also be specified without a regular expression. For example:

Digit   = [0-9];
Integer = digit+ %% gotlnteger(smThis); %%
Copy    = %% smScCopy(aBuffer, 0, smThis->smLength); %%

In the example above digit defines a rule as being a number 0 to 9. Integer is defined to be both a rule, a number of digits, and a semantic action. Copy on the other hand only defines a semantic action.

Semantic actions defined in this way can be used later in the rule and skip sections in place of an ordinary semantic action by using the %%DO keyword. For example:

Integer = Digit+ %%DO Integer;


@PAGE 151 -- ScannerMaker Reference Manual

This is further described in the description of semantic actions below. 3.2.14  The Vocabulary Section

<vocabulary section> :._
'%%VOCABULARY' <vocabulary name> [<token name> '=' <external token code> (<scanner section>)

The vocabulary section is used to specify the vocabulary used by the scanners defined for a specific vocabulary. A vocabulary also defines a set of tokens. The tokens can either be specified in a vocabulary file or directly after the name of the vocabulary in the vocabulary section. Each vocabulary may specify a number of scanners to recognise its set of tokens.

A token must always have an external token code which must be unique in the vocabulary. Tokens may be string tokens, in which case the name of the token is given as a quoted string. All string tokens are automatically defined in the first scanner in the vocabulary that defines them if they are not explicitly defined in a scanner.

ScannerMaker will complain if a token have not been defined, or explicitly undefined, in any of the scanners defined for the vocabulary.

3.2.15  The Scanner Subsection

<scanner section> ::=
'%%SCANNER' <scanner name> [' :' <scanner name>] [<screened token section>] [<undefine token section>]
(<rule definition section>)

where the rule definition section is

<rule definition section> :._ <rule section> <skip section>

The scanner section defines a scanner. It consist of a scanner name, an optional screening section, an optional undefine token section, and rule definition sections. The name of the scanner is local for each vocabulary. That is, the same scanner name can be used in several vocabularies. However, a vocabulary may only define one scanner with a specific name.

The definition
<scanner name>  <scanner name>

defines a scanner which inherits definitions from another scanner. The new scanner copies all rules and semantic actions from the other scanner. For example:

%%SCANNER newScanner : oldScanner %%RULE

@PAGE 152 -- ScannerMaker Reference Manual

defines newScanner to be a copy of oldScanner. The new scanner can then be expanded with new definitions but also restricted by removing a definition or altered by first removing a definition and then redefining them. For example:

%%SCANNER newScanner : oldScanner %%UNDEFINE Integer;
%%RULE
Integer = (0-9A-Fa-f]+;

if the old scanner have a definition of integer it is replaced by the new definition.

ScannerMaker will complain about tokens which has been defined in another scanner than the first and is only predefined in the first scanner. However, if the token is explicitly undefined in the first scanner, ScannerMaker will not complain since the token has been explicitly said to be undefined until it is later defined in a rule or skip section.

3.2.16  The Screened Token Subsection

<screened token section> .. '%%SCREENING' (<token name>

This section specifies which tokens in the scanner can be screened. By default all tokens can be screened.

3.2.17  The Undefine Token Subsection

<undefined token section> :._ '%%UNDEFINE' {<token name> ,'}

This section undefines a predefined or inherited token. All rules associated to the token are marked as undefined.

3.2.18  The Rules Subsection

<rules section> .._
'%%RULE' [<token rule>} ('%%END']
<token rule> .._
<token name> '=' <lookahead rule> [<action>] <string> '_' <lookahead rule> [<action>]

In the rules section the tokens which the scanner should recognize are defined. The token could be both a token name and a string and the definition is a regular expression which can be followed by a lookahead regular expression. For example

integer = integer; integer = integer /

@PAGE 153 -- ScannerMaker Reference Manual

defines that the externally visible token integer is to be an integer, as defined in the definition section above, and it is also an integer followed by a lookahead string ' .. '. This is a rather perplexing definition because of the use of the token integer defined in the definition section in the regular expression and the definition of an external visible token which may be defined in the vocabulary file. However this example shows that it is possible to use the same name for a token defined in the definition section and a token defined in the rules section without name clash. The example also shows the possibility to give multiple internal definitions for the same externally visible token. That is, both definitions return the same external token code.
An alternative definition of integer could be
integer = integer / '..'?;
which is an integer followed by an optional lookahead string ' .. '. Both definitions define exactly the same token but the first set of definitions creates a more efficient scanner because the lookahead is fixed to two characters while the other definition uses a variable length lookahead of either none or two characters.
Note: If possible use fixed length regular expression either in the regular expression preceding the lookahead or in the lookahead (or both) when lookahead is used.
The scanner always tries to find the longest possible token, even when using lookahead. For example
absurd  = (0-9]+/(0-9]+;
locates a string which has one or more digits followed by at least one digit. However, such a definition is absurd because there is no definite way to determine when the lookahead starts but with the convention to always locate the longest token, even this type of definitions has a well defined meaning. The rule
absurd  = (0-9]+/(0-9];
will find the same token as above but is more efficient because the lookahead has a fixed length of one character.

3.2.19  The Skip Subsection

<skip section> :._
'%%SKIP' (<skip rule>} ['%%END']
<skip rule> :._
<token name> '_' <lookahead rule> [<aetion>] <string>   <lookahead rule> [<action>]
This section defines the tokens that should be skipped by the scanner, that is, not be passed to the caller of the scanner function. For example
blank = [ \t\n];

@PAGE 154 -- ScannerMaker Reference Manual

skips all blank spaces ("space", tabs and newline) in the input stream between tokens. Skip tokens are defined exactly in the same manner as for ordinary tokens defined in the rules section including lookahead. The rules for semantic actions are the same as for semantic rules in the rules section.

3.2.20  Regular Expressions

<regular expression> :._ <selection> <concatenation> <closure> <Cut> <grouping> <character class> <character string> <identifier> <end of text> <unknown>

Selection
<selection> .._
<regular expression> '!' <regular expression>

The meaning of selection of two regular expression is that either the left or the right regular expression matches.
For example:

'ab' ! 'cd'

matches either the token 'ab' or 'cd'. Concatenation
<concatenation> :.=
<regular expression> <regular expression>

The meaning of concatenating two regular expressions is to match the left regular expression followed by the right regular expression. The token thus matched are both regular expressions in the concatenation. For example:

'A' 'B'

is the concatenation of the 'A' character (regular expression) and the 'B' character. This matches the input 'AB'.


Closure
<closure> .._
<regular expression> <regular expression> '+' <regular expression> '?' <regular expression> <regular expression> 't'
<m> <n>

@PAGE 155 -- ScannerMaker Reference Manual

<regular expression>    '-' <m> '}' <regular expression> '{' <n> '-' <m> '}'

The first closure repeats the regular expression zero or more times, the second form repeats the, regular expression one or more times while the third form means zero or one time. The other forms indicate a more general form where <n> is a number indicating the minimum number of times which the regular expression should be repeated, if missing zero is assumed. <m> is a number indicating the maximum number of times which the regular expression should be repeated, if missing infinite number of times is assumed. If only <m> is given a repetition of exactly <m> times is assumed.

The operations on regular expressions using curly braces should be used with care because it tends to create large state tables. For example

complex{6}

is equivalent to

complex complex complex complex complex complex

If complex derives 20 states the expression above will derive 120 states. Cut

<cut> .._
<regular expression> '

When a token up to the cut operator is found the scanning is immediately abandoned. For example, this operator is very useful to describe comments in for example 'c'

comment = '/*' (^]* '*/'.;

The meaning of the rule above is to find a ' / *' prefix and then match any character up to and including the first occurrence of a ' * /'. With no cut operator the matched token would be up to the last occurrence ' * /' in the input stream.

Another way to look at the example above is that the cut operator selects the shortest possible token which matches the definition. Without a cut operator the longest possible token which matches the definition will be selected.
Grouping

<grouping> :._
'(' <regular expression>

Grouping are used to alter the priority of operations. For example:

('ab' ! 'cd')+

matches tokens with one or more occurrence of the 'ab' or 'cd' patterns.

@PAGE 156 -- ScannerMaker Reference Manual

For example:

ababcdcdab
Character Class
<character class> :._
'[' (<character>) '[' '^' {<character>}

A character class represents one of the characters given between the square brackets. For example:

[abcd]

represents one of the characters a, b, c, or d. Non-printable characters can be represented by giving their octal or hexadecimal value

\nnn    there nnn is the octal value
\xnn    there nn is the hexadecimal value \n    newline
\t  horizontal tab
\v  vertical tab
\b  backspace
\r  carriage return
\f  form feed

If the backslash character, '\', is followed by a character not mentioned above it is used as it is. That is, if the backslash, hyphen, or right square bracket should be used as a character in the character class they should be preceded by a backslash.

\ \ backslash
\-  hyphen
\ ] right square bracket

Further more the hyphenation character, '-', is used to indicate a range of characters. For example a character class representing any digit can be specified as

[0-9]

If the character ' ^' is given directly after the initial square bracket all characters in the character class definition are not a members of the character class. For example
represents all characters which are not a newline. The '^' character can be quoted by a backslash, '\'.

@PAGE 157 -- ScannerMaker Reference Manual

Character String
<character string> :._ " ' { <character> }

A character string represents the regular expression needed to recognize that string. For example

'BEGIN'

is interpreted exactly as

[B] [E] [G] [I) [N]

Inside a character string the non-printable characters can be represented in the same way as non-printable characters in a character class. However the characters ' ^' '-', and ' ] ' has no special meaning in a character string. To use a

single quote, ' ' ', inside a character string it must be preceded by a backslash
For example

'can\ 't'

represents the character sequence

can't

Identifier
An identifier defined in the definition section can be used in regular expressions. In such a case the definition of the identifier is inserted in that place of the regular expression. For example:

%%DEFINITION
integer [0-9]+; %%RULE
FIXATION    integer [. ]integer;
FLOAT   integer[.]integer([Ee][+\-]integer)?; INTEGER = integer;
End of Text

<end of text> :._ ' EndOfText'

This special symbol matches the end of the input stream, the end of text. The end of the input stream is reached when the reader (as defined in the reader section, see The Reader Section on page 146) returns zero.

The EndOfText symbol is case insensitive and must be the full regular expression. That is, EndOfText can not be combined with selection, concatenation or closure.

@PAGE 158 -- ScannerMaker Reference Manual

Unknown
<unknown> :.= 'Unknown'

This special symbol matches all unknown tokens found in the input stream. An unknown token is always only one character long but may be manipulated as any other token.

The Unknown symbol is case insensitive and must be the full regular expression. That is, Unknown cannot be combined with selection, concatenation or closure.
Operator Priorities and Associativity
In the table below each operator is given in order of priority, and with its associativity:
Priority    Operator    Name    Type    Associativity
I   cut unary   none
2   *   closure unary   none
2   +   closure unary   none
2   ?   closure unary   none
2   { ... } closure unary   none
3   concat. binary  left
4   !   selection   binary  left
The highest operator priority is 1 and lowest priority is 4. 3.2.21 Semantic Actions

<action> .._
'%%' <any character sequence except '%%'> '%%' '%%DO' <action name>

In the rule and skip sections an action can be placed after each token definition, before its trailing semicolon, ' ; '. The action begins and ends with two percent characters, ' % %', or a reference to a semantic action defined in the definition section using the '%%DO' keyword.

All characters inside an action are considered to be code written in the same language as the scanner skeleton. This language is the same as the language specified in the TARGET option. The code in a semantic action is executed when the corresponding token is found. For example:

integer = digit+
%%
unsigned char tmp;
tmp = smThis->smText[smThis->smLength]; smThis->smText(smThis->smLength] = 0; smToken->ival = (int)atoi(smThis->smText); smThis->smText(smThis->smLength] = tmp;

@PAGE 159 -- ScannerMaker Reference Manual

Definitions from the definition section can be referenced. For example:

Integer = Integer %%DO Copy;

Using the definitions above in the description of the definition section the integer found is copied to aBuffer.

Similarly, target language code can be specified in the declaration, context, reader, action, pre hook and posthook sections. Each of these target language code sections begins with its keyword and ends with anything starting with two percent characters. For example:

%%DECLARATION
int commentLevel=0;
int commentModifier=0; %%MAP
By default the character ' `' has special meaning in the target language code sections. This character is called the escape character (see The Escape Directive in the ToolMaker System Description, page 32). By giving an escape character the following character is unconditionally processed. For example, if double percent characters should be used in the code they should be preceded by the escape character. For example

%% printf("%d'%%\n",percent); %%

is translated to

printf("%d%%\n",percent);

instead of terminating at the first pair of percent characters. The escape character is escaped by itself. Thus, ' `    means ' `'.

The code in a semantic action is executed when a token that matches the corresponding definition is found. Each semantic action may be viewed as a function with the following definition:

code = smScAction(smThis,smInternalCode,smToken)
smThis  IN smScContext smToken : IN OUT %%(tokenType) returns INTEGER

In addition the code given in the action section is executed first. The token's external code is determined by the value of the field smCode in the token structure (smToken->smCode in 'c') when the function is terminated. This variable is initially set to the value as specified in the vocabulary file or the vocabulary section or as set in a possible action section (see The Action Section on page 146).

The external token code for the token found can be changed (simulating finding of another token) in two ways by either setting smToken->smCode to the new external code or by returning the new external code by executing a return statement. The external token codes should be one of the enumeration

@PAGE 160 -- ScannerMaker Reference Manual

values defined for tokens in the vocabulary to which the current token belongs, or the predefined enumerators smSkipToken or smContinueToken.

When smSkipToken is returned the current token is skipped, as if it had been specified in the skip section.

When smContinueToken is returned continued scanning will be performed, Continued Scanning on page 171.

3.3 The ToolMaker Common Description file

Unless ScannerMaker is the only Maker used, common declarations of the source position and the token structures should be placed in the ToolMaker Common Description file which is described in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30. Otherwise these two sections may be specified in the ScannerMaker Description file, removing any need for the ToolMaker Common Description file.

3.4 The Vocabulary file

The vocabulary file used by ScannerMaker corresponds to the vocabulary file produced by ParserMaker. The format of the vocabulary file consist of four fields:

1)  The number of the row in the vocabulary file.

2)  The external token code number.

3)  The token name. The token name may either be an identifier; a letter followed by zero or more letters, digits or underscores, or a string as defined by ScannerMaker.

4) The name of the vocabulary to which the token belongs. The vocabulary name should be an identifier; a letter followed by zero or more letters, digits or underscores.

Each field should be separated by blank characters. If multiple vocabularies are defined they must all be defined in the same vocabulary file, ScannerMaker only reads one vocabulary file. Below is an example of a vocabulary file:
0   0   Unknown main
1   1   EndOfText   main
2   2       main
3   3       main
4   4       main
5   5       main
Each token should appear only once for each vocabulary and two token may not have the same external token in the same vocabulary.

@PAGE 161 -- ScannerMaker Reference Manual

For compatibility an older format is also supported. The format of the older vocabulary file is not described. However, if this format is used the end-oftext marker, '$', is replaced with the EndOfText token and all tokens are defined to belong to a scanner called main.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 162 -- ScannerMaker Reference Manual

4   THE SCANNERMAKER COMMAND
The invocation of the scanner generator is performed by the following program call

smk [-help] [<options> ...] <file>

The special option -help gives a short help of available options and their meaning.

The default extension on the ScannerMaker description file is smk which is added if not explicitly stated.

4.1 Parameters

The command takes only one argument, the name of a description file. The description file contains a description of the scanner to be made using a formal language as described in The ScannerMaker Description File on page 138. The argument may appear anywhere on the command line except between any option and its argument.

4.2 Options

One or more options may be specified on the command line overriding any specified options in the options section in the description file. The only options which can not be specified in the options section are
option
-help
-voc <file> -smt <file> -sml <file>

All other options have the same names as in the options section. For a detailed description on how to specify options on the command line see Command Line Option Format in the ToolMaker System Description, page 40.

The following options have no corresponding directive in the options section of the description file and are therefore thoroughly described:

-help

This special option produce a verbose listing of the usage format of the command. Each argument and option is given a short explanation.

-voc <file>

The vocabulary used is read from the <f i l e> as specified as argument to this option. By default the vocabulary is read from a file with the same base name as the description file but with extension voc.

@PAGE 163 -- ScannerMaker Reference Manual

-sml <file>

The specified file is used as list file. By default the name of the list file is the same as the description file but with extension.sml. Note that this option does not produce any list file if no list directives are used.

-smt <file>

The specified file is used as the table file. By default the name of the table file is the same as the description file but with extension smt. Note that this option does not imply that the table file should be saved after source code generation, it simply indicates its name (see also The Maker in the ToolMaker System Description, page 25 for a description of the intelligent generation strategy and File Descriptions on page 138).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 164 -- ScannerMaker Reference Manual

5   SCANNER RUN-TIME USAGE

5.1 Principles of Operation

To use a ScannerMaker generated scanner the following step should be performed:

* create a new scanner context (see below)
* initialise the reading from the input stream (e.g. open the file and attach it to the context)
* call sniScan until end of input

During each call to the scanner the appropriate semantic action will automatically be performed (see Semantic Actions on page 158) in which various of the features of the generated scanner can be used. It is also possible to create additional contexts, using the function smScNew, and switch scanner and vocabulary during the scanning process.


5.1.1   Type: smScContext and smScContextItem

TYPE smScContext IS POINTER TO smScContextItem

TYPE smScContextItem IS STRUCTURE smSize    : INTEGER
smText  : STRING
smLength    INTEGER smBufferOverflow: INTEGER SmPOSition: INTEGER
smLine  : INTEGER smColumn : INTEGER smNextPosition: INTEGER smNextLine: INTEGER smNextColumn: INTEGR smScanner : smScScanner

declarations from the context section END STRUCTURE
A context is the main object in the generated scanner. Almost all functions operate on that object. A context consist of a buffer, source position, scanner, and user defined variables.
In object oriented languages this type is declared as a class named smScContext with the structure components above as public members.
Note: All predefined variables starts with the characters sm and can not be changed. This is not the scanner prefix used as a prefix for the exported functions and the context data type.

@PAGE 165 -- ScannerMaker Reference Manual

The Context Buffer
smSize  : INTEGER

The context buffer is divided into two parts, the token and the input stream, where the input stream always follows the token. Initially the token length is zero and when end of text is found the input stream has a length of zero. The size of the context buffer can be found in the smSize field. Initially the length of the context buffer is zero.

smText  STRING smLength : INTEGER

The variable smText holds the last scanned token and smLength is the length of the token. The characters in smText may be altered freely but if any altered characters are skipped back into the input stream the source position calculation will be wrong if any newline characters was altered or inserted.

Great care should be taken not to alter any characters after the last character in the token permanently. It is alright to alter the character while in a semantic action and then restoring the old character before leaving the semantic action or calling the scanner recursively. For example, to convert a token representing an integer into an integer, the unix standard function atoi could be used. However, this function requires that the string representation is null terminated but ScannerMaker does not null terminate a token string so this must be done explicitly.

Integer = [0-9]+
unsigned char *remind;
remind = smThis->smText[smThis->smLength]; smThis->smText[smThis->smLength] = 0; smToken->ival = atoi(smThis->smText); smThis->smText[smThis->smLength] = remind;
It is very important to restore the character over-written by the null character as in the example above or else the next token would start with a null character.
smBufferOverflow: INTEGER

If the scanning of a token exceeds the maximum token length or the reallocation to a larger buffer fails, characters in the buffer will be skipped. The number of characters saved equals to the minimum length of the token and the only characters saved are the last one in the buffer. The variable smBuf ferover flow holds the number of characters which is skipped. The source position will still however reference the true beginning of the character but the smLength will not include any skipped characters. Thus the true length of the token is the sum of smBufferOverflow and smLength.

If no overflow occurs smBuf ferOverf low will be zero.

@PAGE 166 -- ScannerMaker Reference Manual

Changing the context can be necessary when changing from one source of input to another. This can be achieved by simply replacing the current context variable with a new (created using the smNew function). To be able to restore the previous context the context buffers should be linked or stacked, which is the responsibility of the user


The change of a context should preferably be performed outside the actual generated scanner, e.g. in a function enclosing the smScan function, which recognises and handles situations when this is necessary.


Note: The prehook, action and posthook section and the semantic actions are all called using the same context (the one passed to smScan).
Source Position
smPosition: INTEGER smLine  : INTEGER
smColumn : INTEGER
The source position is only calculated if the appropriate source position directive is given in the source position section. The line number and column number start from one and the position from zero. The position is the number of characters read in this context before the token. The source position will always be correct with one exception. If altered characters are returned to the input stream by using smScSkip instead of smScModi fy and any newline is altered to a character other than the newline character or if a character is altered to a newline, then the source position will be computed incorrectly. However, if the number of newlines are the same the source position will be correct after the next newline following the altered characters. The suggestion is not to return any altered character with the smScSkip function.


When smScModi fy is used to return altered characters to the input stream any token found containing altered characters will have the source position of the token following the token which altered the input stream. For example
'hello' = 'hello' %% smScModify(smThis,"theis",-5) %%; 'the' _ 'the' %% ... %%;
'is'    'is'    % ... %%;
when the token 'hello' is found, the token is altered to 'theis'. If the source position of 'hello' was line one and column five, then the next token should be found at line one and column ten. This is the line number which is reported by 'the', 'is', and the token following 'is'.
smNextPosition: INTEGER smNextLine  : INTEGER
smNextColumn    INTEGER
The next positions gives the next token's position. That is, the token following the current one.

@PAGE 167 -- ScannerMaker Reference Manual

Scanner
smScanner: smScScanner

Which scanner a context should use is determined by the value of the smScanner variable. Available scanners are determined by the description file defining the scanners. An enumeration type is defined containing an enumeration literal for each scanner. The name of the enumeration literal is the scanner prefix concatenated by the vocabulary name and scanner name surrounded by underscores and finally the characters 'Scanner' as a suffix. For example, if the scanners main and comment are defined the following enumeration type is defined (if 'c' is the target language):

typedef enum smScScanner {
* MAIN-MAIN-Scanner= 0,
sm_MAIN COMMENT Scanner= 1,
sm_SET MAIN Scanner = 2 } smScScanner;

By simply changing the value of the smS canner field in the context variable a new scanner is entered. The variable can be changed any time and the effect is immediate. For example, it is possible to change scanner in a semantic action and then continue scanning using the newly selected scanner.

For each vocabulary there is also an enumeration type defined containing enumeration literals for all tokens defined in that vocabulary. The name of the enumeration type is smfollowed by the vocabulary name enclosed by underscores and followed by the characters 'ScToken'. Each enumeration literal is named sm followed by underscore, vocabulary name, underscore, token name or external token code for a string token, underscore, and Token. For example, if 'c' is the target language:
typedef enum sm main ScToken { am-MAIN-UNKNOWN-Token = 0,
* MAIN ENDOFTEXT Token = 1,
* MAIN_2 Token = 2,
* MAIN_INTEGER Token = 3,
} sm main_ScToken;


5.2 Run Time Interface

The run time interface consist of a number of functions. All functions except smScScrScanner, smScScrToken, and smScScrRule operates on a context. In a non-object oriented language the context is always given as the first argument. In an object oriented language these functions are member functions to the smScContext class and messages are sent to a context object.

5.2.1   Function: smScan

code = smScan(smThis,smToken)

@PAGE 168 -- ScannerMaker Reference Manual

smThis  : IN smScContext
smToken IN OUT %%(tokenType) returns INTEGER

This function scans a new token. If successful, the token code is returned and the token structure or record is assigned the token code and source position, if used. If the reader, as defined in the reader section, returns a negative value this is immediately propagated as the return value of the smScan and the scanning is aborted.

5.2.2   Function: smScNew

context = smScNew(smScanner)
smScanner: IN smScScanner returns smScContext

This function is a so called constructor. It constructs a new context with the specified smScanner.

5.2.3   Function: smScDelete

smScDelete(smThis)
smThis  : IN smScContext

This function is a so called destructor. It destroys a context and its buffer. 5.2.4    Function: smScSkip

length = smScSkip(smThis,smLength)
smThis  IN SmContext
smLength    IN INTEGER returns INTEGER

This function changes the token by either replacing characters from the end of the token to the input stream, or by extending it by reading characters from the input stream. The number of characters replaced or read are given by the value of smLength. A negative value replaces characters and a positive value reads characters. The actual number of characters replaced or read are returned. For example,

smScSkip(smThis,-3);

returns the three last characters of the token to the beginning of the input stream. The length of the token will be three characters shorter. However, if it has a length of less than three characters, for example one character, only that many characters will be returned. If the reader, as defined in the reader section, needs to be called to fetch further characters from the input stream and it returns a negative value, this is immediately propagated as the return value of smScSkip and the skipping is terminated.

@PAGE 169 -- ScannerMaker Reference Manual

5.2.5   Function: smScModify

length = smScModify(smThis,smBuffer,smLength)

smThis  : IN smScContext smBuffer : IN STRING
smLength    IN INTEGER returns INTEGER
This function modifies the token or input stream in the same way as smScSkip but all affected characters (replaced to the input stream or appended to the token) are modified by characters from the specified buffer. For example
smScModify(smThis,"123",3);
appends the token with three characters from the input stream and modifies them to be "123". That is, the token now ends with "123".
smScModify(smThis,"123",-3);
returns the three last characters of the token to the beginning of the input stream and replaces them with "123". If the reader, as defined in the reader section, returns a negative value this is immediately propagated as the return value of smScModi fy and the modification is terminated.

5.2.6   Function: smScCopy

length = smScCopy(srThis,smBUffer,smFrom,smTo)

smThis  : IN smScContext
smBuffer    OUT STRING
smFrom  : IN INTEGER
smTo    : IN INTEGER returns INTEGER
Copy the token into the buffer specified. The token's characters are not mapped. The copy starts to copy characters from the smFrom position up to but not including the smTo position from the current token. The number of characters copied is returned. For example, to copy all characters use:
smScCopy(smThis,buffer,0,smThis->smLength);


5.2.7   Function: smScMapCopy

length = smScMapCopy(smThis,smBuffer,smFrom,smTo)
smThis  : IN smScContext
smBuffer    OUT STRING
smFrom  : IN INTEGER
smTO    : IN INTEGER returns INTEGER
Copy the token into the buffer specified in the function call. The characters of the token are mapped using the specified character map as specified in the map section. The copy starts to copy characters from the smFrom position up

@PAGE 170 -- ScannerMaker Reference Manual

to but not including the smTo position from the current token. The number of characters copied is returned.

5.2.8   Function: smScScrScanner

void smScScrScanner(smScanner,smOnOff)
smScanner   IN smScScanner
smOnOff : IN BOOLEAN

This function turns on or off checking of screened tokens for the specified scanner. If the scanner has screened tokens these are not recognized if screening is turned off.

5.2.9   Function: smScScrToken

void smScScrToken(smScanner,smToken,smOnOff)
smScanner   IN smScScanner
smToken IN sm vocabularyname_ScToken
smOnOff IN BOOLEAN

This function turns on or off checking of screened tokens for the specified token. If the token has screened tokens these are not recognized if screening is turned off.

5.2.10  Function: smScScrRule

void smScScrRule(smScanner,smToken,smOnOff)
smScanner   IN smScScanner
smToken IN sm_vocabularyname_ScToken
smOnOff IN BOOLEAN

This function turns on or off checking of the specified token. If the token is a screened token it is not recognized if screening is turned off.

5.3 Recursive Calls and Continued Scanning

There are two ways in which scanning may proceed directly from inside a semantic action without actually returning from the current call. Either the scanner can be called recursively or the scanning may be continued.

5.3.1   Recursive Calls

Inside any action or target language code section it is possible to call the scanner recursively. However smToken should never be passed to any called scanner because it will over-write the current token code. Also note that the variable smToken is not defined in the code section.

The current token is reset by a recursive call. That is, after a recursive call the
smText and smLength will refer to the last scanner token. For example

@PAGE 171 -- ScannerMaker Reference Manual

INCLUDE = '#include'
TmToken myToken;
/* #include "astring" */ if(smScan(smThis,&myToken)==2){
/* open file and create a new context
} else (
error("Illegal include statement");
}
After calling smScan () the string ' #include' which could be found in smText is replaced by the next token, in this case hopefully a string.

5.3.2   Continued Scanning


It is also possible to continue scanning after a token is found by setting the external code to smContinueToken or returning smContinueToken in the action section or the semantic actions. The current token will be appended with the new token found after a continued scanning is made. The new token will be returned.That is, in the example below the complete string will be found in the last semantic action.


For example
STRING = "" P "I '"' / '",
%% return smContinueToken; %%;
STRING =
%% ...
or
STRING = ' ' [-I ' ' / , ,
%% smCode=smContinueToken; %%; STRING = "" P"] ""
%% ... %%;
Continued scanning can only be used in the action section and inside semantic actions.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 172 -- ScannerMaker Reference Manual

A   THE PL/O EXAMPLE
This example is a part of the pl/0 example used throughout the ToolMaker documentation. The ToolMaker System Description contains a detailed walkthrough of the relevant parts of the example. This appendix contains the files relevant for ScannerMaker.
A.1 plO.smk -- The ScannerMaker Description File ------------------------------------------------------
-- p10.smk  Date: 1993-06-24/toolmake -- p10 -- ScannerMaker description file

-------------------------------------------------------- Created:   1993-04-27/reibert@roo -- Generated: 1993-06-24 12:42:46/toolmake v2,r0,c12 ------------------------------------------------------

%%OPTIONS Verbose;
%%IMPORT
#include <stdio.h>

#include "plOList.h" #include "plOScan.h"

%%EXPORT

extern void scan(TmToken *token);
extern int plOScanEnter(char *fileName); extern void plOScanTerminate(void);

%%CONTEXT
char *fileName; int fd;
plOScContext previous; int fileNo;

%%READER
return read(smThis->fd, (char *)smBuffer, smLength);
%%DECLARATIONS
static plOScContext lexContext;
static int fileNo = 0;/* Count included files */ int plOScanEnter(
char fnm[]/* IN - Name of file to open
plOScContext tmp; ){
tmp = p10ScNew(p10 MAIN MAIN-Scanner); if (fnm == NULL)
tmp->fd = 0;
else if ((tmp->fd = open(fnm,0)) < 0)
{
p10ScDelete(tmp);
return 0;

@PAGE 173 -- ScannerMaker Reference Manual

} else {
tmp->fileName = fnm; tmp->fileNo = fileNo++; tmp->previous = lexContext; lexContext = tmp;

return 1;
/*

plOscanExit()

Terminate and delete the current lexical context. static void plOScanExit(void) plOScContext old;

close(lexContext->fd);
old = lexContext;
lexContext = lexContext->previous; plOScDelete(old);
1*

plOScanTerminate()

Make sure all contexts are terminated (e.g. in case of parser abort).
void plOScanTerminate(void)

while (lexContext)

plOScanExit();
/*

scan()

Outer scanner called from the parser. Handles switching of contexts.
*/
void scan(
TmToken *token ){
plOScan(lexContext, token);

switch (token->code) {

case p10 MAIN_ INCLUDE Token:
if (plOScanEnter(token->stringValue)) { TmSrcp srcp, start;

srcp = token->srcp;
srcp.line++;/* Make include start on next line srcp.col = 1;
*/

@PAGE 174 -- ScannerMaker Reference Manual

start.file = fileNo; start.line = 0;
plOLiEnter(&srcp, &start, token->stringvalue); } else {
plOLog(&token->srcp, 199, sevFAT,

token->stringValue);

/* Get next token and return instead of the INCLUDE */ pl0Scan(lexContext, token); break;

case p10 MAIN ENDOFTEXT Token: plOScanExit();
if (lexContext)/* If still more input get a token plOScan(lexContext, token); break;
}

%%POSTHOOK

smToken->srcp.file = smThis->fileNo; %%DEFINITIONS

Letter = [A-Za-z\xCO-\xD6\xD8-\xF6\xF8-\xFF]; Digit = [0-9];
White = [ \t\n];
%%VOCABULARY main %%SCANNER main %%RULES
NUMBER = Digit+
%%
plOScCopy(smThis,
(unsigned char *)smToken->stringValue, 0,
smThis->smLength); smToken->stringValue[smThis->smLength] = 0; smToken->integerValue=atoi(smToken->stringValue);


IDENTIFIER = Letter ('_ ? Letter !  ? Digit)*

plOScCopy(smThis,
(unsigned char *)smToken->stringValue, 0, smThis->smLength);
smToken->stringValue[smThis->smLength] = 0;
Include = '$INCLUDE'
TmToken token; int i;
char c;

plOScan(smThis, &token);    /* Get file name */ do {
i = pl0ScSkip(smThis, 1);
c = smThis->smText[smThis->smLength-1];
} while(c !_ '\n' && i != 0); /* Skip to EOL or EOF
strcpy(smToken->stringValue, token.stringValue);

@PAGE 175 -- ScannerMaker Reference Manual

Unknown = Unknown; EndOfText = EndOfText;
%%SKIP
Blank = White+; -- Skip any white space Comment = -- [-\n]*[\n];-- and Ada style comments
%%END

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 176 -- ScannerMaker Reference Manual

B   ERROR MESSAGES

Error messages produced by ScannerMaker are output to the terminal, and if the option List Input; is set, messages are also output to the list file.
For a description of the format of error messages refer to Message Format in the ToolMaker System Description, page 49.
B.1 Message Explanations

The following list gives a brief summary of the error messages and in some cases the actions that should be taken by the user. An error message containing '%n', where n is a number, means that an insert string is inserted in that position during the actual generation of the message.
Messages with numbers less than 100 are messages common for all Makers. These are described in Messages Explanations in the ToolMaker System Description, page 50. Messages indicating license problems or limitations are described in License Errors in the ToolMaker System Description, page 51.
100 Parsing resumed.
This error specifies a point in the description file where parsing could be resumed after a wild error.
101 %1 inserted.
The token or tokens is inserted into the description file because the ScannerMaker thought it was missing.
102 %1 deleted.
The token or tokens is deleted from the description file because the parser thought it was wrongly inserted.
103 %1 replaced by %2.
The token is replaced with another token. More than one token can be replaced with one or more tokens.
104 syntax error, stack backed up.
Severe syntax error there the normal error recovery strategies failed and the parser was forced to do severe error recovery. The meaning of the scanner description is probably lost.
105 Syntax error.
An unspecified syntax error. This error message should not appear.

@PAGE 177 -- ScannerMaker Reference Manual

106 Parser stack overflow
107 Parse table error.
108 Parsing terminated.
These are errors in the scanner generator. Contact your ToolMaker contact person for bug report.
207 Can not overwrite table file "Al".
The protection of an existing table file prevents ScannerMaker to over-write it.
208 Can not overwrite list file "%1".
The protection of an existing list file prevents ScannerMaker to overwrite it.
209 Scanner "%1" already defined.
The scanner is already defined earlier in the description file.
210 Token "%1" already screened.
The token is already screened in this scanner.
211 Token "A1" not in vocabulary.
The token can not be found in the vocabulary.
212 External code already exist.
The external token code is already used in this scanner.
213 Token name already exist.
The token is already defined in this scanner.
214 Multiple matches of END OF TEXT token in scanner.
Only one token can be defined to match the end of text.
215 Multiple matches of UNKNOWN token in scanner.
Only one token can be defined to match unknown tokens.
216 END OF TEXT token not defined.
There is no token which match the end of text.
218 UNKNOWN token not defined.
There is no token which match unknown tokens.

@PAGE 178 -- ScannerMaker Reference Manual

220 String contains mapped or excluded character, or characters not in the current character set.
Only characters in the current character set are allowed within string tokens. Mapped or excluded characters are not allowed.
221 Automatically defined in "%1".
The string token is not defined in the scanner but it is automatically defined to match itself.
222 Not defined in "%l".

The token is not defined in the scanner.
223 Vocabulary file "%l" not found.

The vocabulary file can not be found.
224 Line number expected.
Line number is expected in the first field of the vocabulary file.
225 External code expected.

External token code is expected in the second field of the vocabulary file.
226 Old end of text symbol, converting to END OF TEXT.

The old end of text symbol ' $ ' is found. Convert it to the token EndOfText.
227 Token name expected.

Token name is expected in the third field of the vocabulary file.
228 Old format, using "main" as vocabulary.
Old format of vocabulary file. All tokens are considered to belong to the vocabulary main.
229 Scanner name expected.
Scanner name is expected in the fourth field of the vocabulary file.
230 End of line expected.

End of line is expected in the vocabulary file.
231 Must be one character long.

The character string must be one character long. The character may be quote character.

ScannerMaker Reference Manual


@PAGE 179

232 Set not uniquely mapped.
The set is not unique. That is, each character in the set must have a unique character equivalent or be skipped.
233 Token already defined.
Token is already defined.
234 Scanner not found.
The scanner reference is not found.
235 Token reference not found in scanner "%l".
The token referenced in the scanner is not found.
236 Token not defined.
The token is not defined in the scanner.
237 Number must be greater than or equal to the first number.
The first number in the general closure specification must be less than the last number.
238 Class contain mapped or excluded characters.
Mapped or excluded characters are not allowed in a class.
239 Token not defined.
The token is not defined in the definition section.
240 Scanner description file "%1" not found.
The description file can not be found.
241 The cut operator must lead to a final state.
The cut operator must be used in such as way that the character preceding it matches the last character in the regular expression.
242 Not accepted by "Al".
The screened token is not accepted by the token used to screen it.
243 %1 definition takes precedence (ambigous accepting state).
Two or more tokens have the same accepting state.

@PAGE 180 -- ScannerMaker Reference Manual

244 Old format, defines UNKNOWN with external code 0.
Old format of the vocabulary file implicitly defined unknown tokens to be 0.
245 Action not defined.
The action is not defined in the definition section.
246 Action already defined.
An action can only be defined once.
247 Name of set expected.
The name of the set being defined was expected.
248 Set already defined.
A set with the same name is already defined.
249 Unexpected end of set.
More characters are expected in the set.
250 Character already defined.
It is illegal to define the same character twice in a set.
251 Unknown token, ignored.
Unknown token found in the set.
252 Character %1 multiply defined in %2 set.
It is illegal to define the same character twice in a set.
254 Specified set %1 does not exist.
The set is not defined.
255 Vocabulary already defined.
Vocabularies must have unique name. A vocabulary with the same name has already been used in this description file.
256 Vocabulary not defined.
The vocabulary can not be found in the vocabulary file.
257 Scanner already defined.
A scanner with the same name is already defined in the same vocabulary.

@PAGE 181 -- ScannerMaker Reference Manual

258 Scanner not defined.
The scanner is not defined in the same vocabulary.
259 Token is not defined in this vocabulary.
The token must be defined in this vocabulary or be specified in the undefine section of the scanner.
260 Screening turned off, no other token may screen it.
No token was found in the scanner which could be used to screen the token. The token will be part of the scanner.
261 Token predefined in %1 scanner.
The token is predefined in the first scanner defined for the vocabulary.
262 Section already defined.
The specified code section can only be used once in the description file.
401 Scanner description file "%1" not found.
The scanner description file could not be found.
402 Trouble producing code.
It was not possible to generate any target language code. The problem may be that generated files could not be written due to protection problem, older protected files or protected current directory, or an error in the skeleton file.
405 Target language "%1" not officially supported.
This warning is issued if the target language is set to a language not officially supported. Note that the option value is case sensitive and the message may be caused by a typing error.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 182 -- ScannerMaker Reference Manual

C   DESCRIPTION LANGUAGE
This appendix contains a syntax summary of the ScannerMaker description language. For a full discussion of the language, see The ScannerMaker Description File on page 138.
For a brief discussion of the notation used in this description see appendix C in the ToolMaker System Description, SYNTAX NOTATION, page 52.


C.1 Language Syntax
<description file> :._
(<toolmaker section>) (<target code section>) (<set definition section>) (<general definition section>) (<vocabulary section>}

<toolmaker sections> :._
( <options section> ]
( <import section> I <srcp section>
<token section> }

<import section> :._
see the ToolMaker System Description

<srcp section> :._
see the ToolMaker System Description

<token section> :._
see the ToolMaker System Description

<options section>
'%%OPTIONS' (<directive>} ['%%END']

<directive> :._
<common directive> <optimize directive> <trace direvtive> <set directive> <pack directive> <screening directive> <list directive> <token size directive> <token limit directive> <exclude character directive>

<common directive> _ <target directive> <os directive> <prefix directive> <library directive> <escape directive> <width directive> <height directive> <generate directive> <force directive>

<optimize directive> ['NO'] 'OPTIMIZE'

@PAGE 183 -- ScannerMaker Reference Manual

<generate directive> :._
['NO'] 'GENERATE' <generate> ',

<generate> :.= 'SOURCE' 'TABLES'

<verbose directive> :._ ['NO'] 'VERBOSE' ',
<trace directive> :._ ['NO'] 'TRACE'

<set directive> .._ 'SET' <set name> ',

<set name> :._ <string>

<pack directive> :_ 'NO' 'PACK' 'PACK' <pack> {'
<screening directive>
'NO' 'SCREENING' ',
I 'SCREENING' <minimum token size> ',

<minimum token size> <number>

<list directive> :._
'NO' 'LIST'
'LIST' <list> {',   <list>)

<list>
'SCREENING' 'TOKEN'
.MAP,
'SET' 'NFA' 'DFA' 'RULE'

<escape directive> :._
'NO' 'ESCAPE' '
'ESCAPE' <escape character>'

<width directive> :._ 'NO' 'WIDTH' ' 'WIDTH' <width> ',
<width> .._ <number>
<pack>
'ROW' 'COL' 'LES' 'GCS' 'RDS' 'ERROR'
<pack>)

@PAGE 184 -- ScannerMaker Reference Manual

<height directive> :._ 'NO' 'HEIGHT' ' 'HEIGHT' <height>

<height> .._ <number>

<target operating system directive>

'OS' <operating system> ',
<operating system> :._ <string>

<target language directive> :._

'TARGET' <language> ',

<language> :._ <string>

<library directive> :._ 'LIBRARY' <library>

<library> :._ <string>

<prefix>
'PREFIX' <system name prefix>
<system name prefix> :. <string>

<token size directive> :._
'TOKENSIZE' <minimal token size> '

<token limit directive> ::=
'TOKENLIMIT' <maximal token size> '

<exclude character directive> ::'EXCLUDE, <exclude character> ',

<target code sections> ::= <declaration section> <context section> <export section> <code section> <reader section> <prehook section> <posthook section> <action section>

<declaration section> ::=
'%%DECLARATION' <target language code> ['%%END'3

<context section> :._
'%%CONTEXT' <target language code> ['%%END']
<code section> .._
'%%CODE' <target language code> ['%%END']

<export section> :._
'%%EXPORT' <target language code> ['%%END']

@PAGE 185 -- ScannerMaker Reference Manual

<reader section> :._
'%%READER' <target language code> ['%%END']

<action section> .._
'%%ACTION' <target language code> ['%%END']

<prehook section> :._
'%%PREHOOK' <target language code> ['%%END')

<posthook section> :._
'%%POSTHOOK' <target language code> ['%%END']

<general definition section> :._ <map definition section> <definition section>

<set section> :._
'%%SET' <set name> {<set>} ['%%END']

<set> :._
<character>
<hex digit> <hex digit>
<map section>
'%%MAP' (<character map>) ['%%END']

<character map> :._
<character class> ' ' <character class>

<definition section> :._
'%%DEFINITION' {<definition>) ['%%END']

<definition> .._
<definition name> _
[<selection rule>] [<action>]';'
<vocabulary section> :._
'%%VOCABULARY' <vocabulary name>
<token name> '=' <external token code> ';'} {<scanner section>]
<scanner section> :._
'%%SCANNER' <scanner name> [':' <scanner name>] [<screened token section>] [<undefine token section>] {<rule definition section>}

<screened token section> '%%SCREENING' {<token name> ';'}

<undefined token section> :._ '%%UNDEFINE' (<token name> ;'}

@PAGE 186 -- ScannerMaker Reference Manual

<rule definition section> :._ <rule section> <skip section>

<rule section> :._
'%%RULE' (<token rule>) ['%%END']

<token rule> .._
<token name>    <lookahead rule> [<action>]
<string>    _' <lookahead rule> [<action>]
<skip section> :._
'%%SKIP' {<skip rule>) ['%%END']
<skip rule> :._
<token name>    <lookahead rule> [<action>]
<string>    _' <lookahead rule> [<action>] ',
    <lookahead rule> :._
    <selection rule> ('/' <selection rule>]
    <selection rule> :._
    [<selection rule> '! '] <concatenation rule>
    <concatenation rule> :._
    [<concatenation rule>] <closure rule>
    <closure rule> :._
        <item>  '+' ')'
        <item>
        <item>
        <item>
        <item>
            '?'
            '{' <number> '}'
            '{' [<number>] - [<number>]
    <item>
        <definition name>
        <string>
        <character class>
            '(' <selection  rule> ')'
    <character class> :._
    [   {<character>) ']'
        (<character>) ']'
    <action> --

    '9696' <target language code> '%%'
Note that every keyword starting with ' %%' can be specified using both up

per or lower case letters and it may also be specified in plural.
C.2 Lexical Items
<upper case letter> :._ 'D' 'E' 'F' 'G' 'H'
'A' 'B' 'K' 'L' 'M' 'N' '0' 'P,
'I' 'J'

@PAGE 187 -- ScannerMaker Reference Manual

dower case a'


Y'
,R, I   'S' I   ,T, I   'U' I   ,V' I   'W' I   ,X,
letter> :._
'b' 'c'
'k'
z'
'd' '1'
'e'
'f' 'n'
,g,
'o' 'w'
'h' ,p,
'x'
<letter> :._
<upper case letter>

<digit> .._ '0'
'5,
<special  character> :._
* ( ' ')
<target language code> :._
any characters in the target language except the escape character, see The ScannerMaker Description File on page 138.
'1' '6'
'2'
'7'
<lower case letter>
'3' '8'
'4'
,9,
%,
<token name> :._
<letter> (<letter> I <digit> <definition name> .._
<letter> {<letter> I <digit> I _'}
* 'z'
<string> .._
''I (<letter> I <digit> I <special character>} ...

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 188 -- ScannerMaker Reference Manual

D   TARGET LANGUAGE DETAILS
This appendix describes the actual definition of the run-time environment by the generated scanner for different target languages.


D A 'c'


Types
typedef enum smScScanner { sm_vocabularyname_scannername_Scanner = scannercode,
} smScScanner;

typedef enum sm_scannerName_ScToken { sm_vocabularyname_tokenname_Scanner = tokencode,

} sm scannerName_ScToken;

typedef struct smScContextltem *smScContext;
typedef struct smScContextltem { int smSize; int smLength; unsigned char *smLength; int smLine; int smColumn; int smPosition; int smNextLine; int smNextColumn; int smNextPosition; smScScanner smScanner; code from context section
} *smScContext,smScContextItem;
Functions
int smScan(smThis,smToken) smScContext smThis; %(tokenType) *smToken;

smScContext smScNew(smScanner) smScScanner smScanner;

void smScDelete(smThis) smScContext smThis;

int smScSkip(smThis,smLength) smScContext smThis; int smLength;

int smScModify(smThis,smBuffar,smLength) smScContext smthis; int unsigned char *smBuffer; int smLength;

int smScCopy(smThis,smBuffer,smFrom,smTo) smScContext smThis; unsigned char *smBuffer;

@PAGE 189 -- ScannerMaker Reference Manual

int smFrom; int smTo;
int smScMapCopy(smThis,smBuffer,smFrom,smTo) smScContext smThis; unsigned char *SmBuffer; int smFrom;
int smTo;

void smScScrScanner(smScanner smOnOff) smScScanner smScanner; int smOnOff;

void smScScrToken(smScanner,smToken,smOnOff) smScScanner smScanner; sm_vocabularyname_Token smToken; int smOnOff;

void smScScrRule(smScanner,smToken,smOnOff) smScScanner smScanner; sm_vocabularyname Token smToken; int smOnOff;


D.2 'ansi-c' and 'c++'
This interface is used both for 'ansi-c' and 'c++'. Types
typedef enum smScScanner {
sm_vocabularyname_scannername_Scanner scannercode,

} smScScanner;

typedef enum sm_scannerName_ScToken f sm_vocabularyname_tokenname_Scanner = tokencode,

} sm_scannerName ScToken;

typedef struct smScContextltem *smScContext;
typedef struct smScContextltem { int smSize;
int smLength;
unsigned char *smLength; int smLine;
int smColumn; int smPosition; int smNextLine; int smNextColumn; int smNextPosition; smScScanner smScanner; code from context section
} *smScContext,smScContextltem;
Functions
int smScan(
smScContext smThis, %(tokenType) *smToken)

@PAGE 190 -- ScannerMaker Reference Manual

smScContext smScNew( smScScanner smScanner)

void smScDelete( smScContext smThis)

int smScSkip( smScContext smThis, int smLength)

int smScModify(
smScContext smThis,
int unsigned char *smBuffer, int smLength)

int smScCopy(
smScContext smThis, unsigned char *smBuffer, int smFrom,
int smTo)

int smScMapCopy(
smScContext smThis, unsigned char *smBuffer, int smFrom,
int smTo)

void smScScrScanner( smScScanner smScanner, int smOnOff)

void smScScrToken(
SmScScanner smScanner, sm_vocabularyname_Token smToken, int smOnOff)

void smScScrRule(
smScScanner smScanner, sm_vocabularyname_Token smToken, int smOnOff)


D.3 Object oriented 'c++' (proposal)
This is a suggestion how an object-oriented 'c++' interface may look like. Currently there exist no such interface. 'c++' users should use the 'ansi-c' interface to generate source code compilable with 'c++' compilers.
Types
typedef enum smScScanner { sm_vocabularyname_scannername_Scanner scannercode,

smScScanner;

typedef enum sm scannerName ScToken ( sm_vocabularyname_tokenname Scanner = tokencode,

) sm_scannerName_ScToken;

@PAGE 191 -- ScannerMaker Reference Manual

class smScContextItem {
public:
int smSize; int smLength;
unsigned char *smLength; int smLine;
int smColumn; int smPosition; int smNextLine; int smNextColumn; int smNextPosition; smScScanner smScanner;
public:
int smScan(
%%(tokenType) *smToken); smScContext(
smScScanner smScanner); -smScContext O ;
int smScSkip(
int smLength); int smScnodify(
unsigned char *smBuffer,
int smLength); int smScCopy(
unsigned char *smBuffer,
int smFrom,
int smTo); int smScMapCopy(
unsigned char *smBuffer,
int smFrom,
int smTo);
declarations from context section
};

void smScScrScanner( smScScanner smScanner, int smOnOff)

void smScScrToken(
smScScanner smScanner, sm_vocabularyname Token smToken, int smOnOff)

void smScScrRUle(
smScScanner smScanner, sm_vocabularyname Token smToken, int smOnOff)

@PAGE 192 -- ScannerMaker Reference Manual


==================================================
Part IV
ListerMaker
Reference Manual

@PAGE 195 -- Part IV Contents
@PAGE 197 -- ListerMaker Reference Manual


@PAGE 198 -- ListerMaker Reference Manual

2   CONCEPTS AND ASSUMPTIONS

2.1 ListerMaker and Lister

ListerMaker is a software tool to produce Listers. The term Lister is used to describe a software component or subroutine package designed to handle messages issued during analysis of an input, typically error and warning messages. A Lister also allows production of listing files containing the input and any associated messages. It is also possible to retrieve the messages one by one from the Lister.
ListerMaker is the tool and Lister is thus the subroutine package produced by that tool.

2.2 Source Positions

The most important concept in ListerMaker is the source position. A source position is an identification of a position in the source (input) worked upon by the application (i.e the program written by you, the tool writer). Although perfectly usable anyway, conceptually this is the first assumption made by ListerMaker, that the application is reading its input from a file. A source position is a structure containing a column, a line and optionally a file number.
A source position is sent to Lister together with every message logged. This makes it possible for the Lister to find and show the source corresponding to the error and to place the message at the correct point in the output. A message that should be placed at the end of the listing of a file should have the line component set to 0 (zero). All such messages are collected and printed after listing the file. In case multiple files are handled, global messages, i.e. messages pertaining to the complete input can be collected and shown after all files are listed if the file component is set to -1.
Note: The automatic source position calculation of ScannerMaker can be used to create the line and column part of the source position information.

2.3 Messages

A message is actually a number of different things. The first meaning of a message is one number and corresponding text in the Message section in the description file (see below). This type of message is a template for actual messages output to the end-user.
The second use of the term is the call to Lister to log a message, this call carries among other things a message number referring to the message in the previous sense, i.e it refers to a template found in the description or message file.

ListerMaker Reference Manual


@PAGE 199

The third use is the actual presented text together with the source where the error was discovered. This is produced by the Lister using a call to a list function after all messages have been logged and shown on the terminal or the screen.
A final observation on error messages is that although the term is error message it does not actually have to indicate errors (other classes of messages handled by a Lister is Informational, Warning, Fatal and System messages) but is used for convenience throughout this document. ListerMaker does not place any restrictions or assumptions on what to do when a message is logged, the recovery, abortion of execution or other action is totally up to the implementor.


2.4 Error Message Templates and Insert Strings

As described above an error message starts out as a template in the description file. These templates consist of a number used to identify the message and a string which is the actual message each taking up one line in the error message file. For example
102 '%l deleted.';

The message string may contain insertion markers ('%d', where d is a digit). This allows a message to be customised during run-time by inserting additional information in the message clarifying the meaning, such as the name of an identifier. The needed number of insert strings must be concatenated and sent to Lister in the log call. Lister will then extract the insert strings and insert them at the appropriate places in the message before presenting it to the user.


2.5 Severities

A logged message is also associated with a severity code. This code is not implied by the message code, as it sometimes might be handy to be able to log a message with the same code but with different severities. An example of this is the insertion of a symbol by a parser, if the symbol was just a comma or semicolon, this might be considered a Warning, but if the inserted symbol was an identifier it surely must be an Error as the parser has no idea as to what identifier the programmer meant.
ListerMaker (and the Lister) defines the following severity levels (in order of increasing severity):
sevINF, sevWAR, sevERR, sevFAT, sevSYS

corresponding to Informational, Warning, Error, Fatal and System messages. Any semantic meaning of these, except for their ordering, is not assumed by the Lister, it is only used as a classification of the messages.

@PAGE 200 -- ListerMaker Reference Manual

The most serious severity logged so far may be read by the function 1mSeverity ().

2.6 Listing Types

In order to direct Lister to produce the selected kinds of information in the listing the generated Lister also defines an enumerated type. One of the parameters to 1mLi s t ( ) is a set of values from this type.
Value   Description
11 SUM  Print a summary of the number of messages found
liERR   Print source lines with messages associated to them in the list
1 i0K   Print source lines without any messages in the list 1 i INCL List and show (as appropriate) included files 1 iHEAD Print a header on top of all pages
Lister also has a shorthand notation for two common combinations of these, 1 iTINY, which is a tiny listing including a header and source for just those lines that have messages associated to them and a summary, and 11 FULL, which also shows the source lines without messages. Normally a tiny list is useful to present on the screen, and a full list if listing to a file.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 201 -- ListerMaker Reference Manual

3   LISTER PRODUCTION

3.1 The ListerMaker Description File

The main information necessary to produce a Lister is the message templates. These are normally written in a description file used by ListerMaker.
To inform ListerMaker how your Lister is to work there is a number of options that you may choose. These include for example whether to include routines for list production and the prefix for all the externally visible functions in the produced Lister.
After setting up a directory using toolmake there should exist a default description file prepared with all necessary options set to their default values and some example messages. An example of a ListerMaker description file is included in appendix A, THE PLIO EXAMPLE, on page 220.
The structure of the ListerMaker description file is
<description file>  _
<toolmaker sections>
<message section> { <message section> }
<toolmaker sections> :._
[ <options section>
{ <import section> I <srcp section> }

The import and srcp sections are further described in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30. These sections are normally located in the ToolMaker description file and should be put in the ParserMaker description file only when developing a stand-alone
Lister.

3.1.1   Lexical items

Symbols in the ListerMaker description language are constructed from using upper case letters from the ISO-8859-1 character set, lower case letters (ISO8859-1) and digits.
<letter> :._ <upper case letter> I <lower case letter>
<digit> :._
'0' 'l' '2' '3' '4'
'5' '6' '7' ,8,
<number> :._ <digit>+   I <digit>   }
<name>  <letter> {<letter>
<quoted string> :._
{<letter> I <digit> I <special character>} ...

@PAGE 202 -- ListerMaker Reference Manual

3.1.2   The Options Section

<options section>   _
'%%OPTIONS' <directive> (<directive>)

<directive> .._
<common directive> <listings directive> <include directive> <message directive> <limit directive>
In the options section various options can be set. The available options for ListerMaker are described below. The term default describes the initial setting unless otherwise stated in the ToolMaker Common Description file when appropriate (see The ToolMaker Description File in the ToolMaker System Description, page 27).
['%%END' I
These options can be overridden by options given on the command line when ListerMaker is invoked (see THE LISTERMAKER COMMAND on page 206). If an option is not specified its default value is used. The default options are:
No Verbose;
Target 'ansi-c'; Os 'SunOS'; Prefix 'lm';
Library '$TMHOME/lib/ansi-c'; Escape ...
width 78; Height 60; Generate source; No Force; Listings single; Include; Limit 100; Messages embedded;
Note however that the settings of common options in the ToolMaker Common Description file influences the default values (see The Options Section in the ToolMaker System Description, page 30, and Prefix Management in the ToolMaker System Description, page 42).

3.1.2.1 Common Directives

<common directive> _ <prefix directive> <escape directive> <target directive> <os directive> <library directive>
The common directives are directives available for all Makers in the ToolMaker kit. For a detailed description of these refer to The Options Section in the ToolMaker System Description, page 30. The directives listed above are the directives relevant for ListerMaker, and if used overrides settings and default values from the ToolMaker Common Description file.

@PAGE 203 -- ListerMaker Reference Manual

The prefix directive does not inherit its default value, instead it defaults to 'lm' if not explicitly set in the .tmk file. If set in the ToolMaker Common Description file and not used in the ListerMaker Description file it defaults to the system prefix (the value set in the ToolMaker Common Description file).

3.1.2.2 The Listings Directive

<listings directive> ::
'LISTINGS' <listings option>
{',' <listings option>} ', ['NO'] 'LISTINGS'
<listings option> ::=
'SINGLE' I 'MULTIPLE' I 'SEPARATE'

The listings directive tells ListerMaker to include the functions for producing listings in the generated Lister module. In cases where only message by message retrieval using the lmMsg () function is used the NO LISTINGS option may be specified to reduce the amount of code in the Lister.
Under certain circumstances it is necessary to make a list of multiple source files, for example if the application is checking the interfaces between program modules. If this directive is specified, ListerMaker will generate a ImL i s tm () function, which may be used instead of 1mL i s t () to achieve this. See Multiple Input Files on page 210.
The functions to use for separate listings of multiple input files (see Separate Listing of Multiple Input Files on page 211) is only generated into the Lister if the value SEPARATE is selected.
The default value is.
Listings SINGLE;

3.1.2.3 The Include Directive

<include directive> :._ ['NO'] 'INCLUDE' ',

The include directive specifies if using and nesting source files shall be allowed. If NO INCLUDE is specified, file handling will not be included in the generated Lister.
The default value is:
Include;

3.1.2.4 The Limit Directive

<limit directive> ::= 'LIMIT' <number' ';

@PAGE 204 -- ListerMaker Reference Manual

The Messagelimit directive indicates the maximum number of messages possible to log using lmLog () . Any integer greater than 0 (zero) is allowed. Note that also the number of calls to lmLiEnter (), lmLiExit (), lmLiOf f (), lmLiOn (), 1mLiPage (), lmSkipLines () (i.e. all COLLECTING phase functions) are included in this calculation.
The default value is:


Limit 100;

3.1.2.5 The Message Directive

<message directive> .._
'MESSAGE' <target option> ',
<message option> :-'FILE' I 'EMBEDDED'
The message directive tells ListerMaker whether the messages shall be put in a separate file to be read at run-time or embedded in the generated Lister source code.


The default value is:


Message EMBEDDED;


3.1.3   The Messages Sections

<messages section> .._ '%%MESSAGES' <name> [<message> {<message>}] ['%%END']

<message> :._ <number> <quoted string> ',
Multiple message sections may be specified. Using the generated initialisation call (1mLilnit ( )) the section used may be selected during run-time. Example:


%%MESSAGES english
10 'Syntax error.'; 11 'Illegal symbol.';
%%MESSAGES swedish
10 'Syntaxfel.';
11 'Felaktig symbol.
%END

3.2 The ToolMaker Common Description File

Unless ListerMaker is the only Maker used, common declarations of the source position and the token structures should be placed in the ToolMaker

@PAGE 205 -- ListerMaker Reference Manual

Common Description file which is described in THE TOOLMAKER DESCRIPTION FILE in the ToolMaker System Description, page 30. Otherwise these two sections may be specified in the ListerMaker Description file, removing any need for the ToolMaker Common Description file.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 206 -- ListerMaker Reference Manual

4   THE LISTERMAKER COMMAND

The invocation of ListerMaker is performed by a command of the form
lmk [-help] [<options> ...] <file>

The special option -help gives a short help of available options and their meaning.

4.1 Parameters

The ListerMaker command takes only one argument, the name of a description file. The description file contains a description of the lister to be generated using definitions as described in The ListerMaker Description File on page 201. The argument may appear anywhere on the command line except between an option name and its arguments. The default extension for the ListerMaker description file is Imk.

4.2 Options

One or more options may be specified on the command line overriding any specified options in the options section in the description file.
All options are available as command line options, the general format is:
-[-]optionname [optionvalue]
The option names corresponds exactly to the names given in the section The Options Section on page 202. The option value (if required) corresponds to allowed values of the option. To turn an option on, one dash is used, to turn an option off two dashes are used. For example, to turn the verbose option on, use -verbose, to turn it off, use --verbose, which is equivalent to specifying NO VERBOSE in the options section.
Please refer to the corresponding options and directives in The Options Section on page 202 for a detailed description of the various options. The general command line option format is described in Command Line Option Format in the ToolMaker System Description, page 40.
The special option
-help

produce a verbose listing of the usage format of the command. Each argument and option are given a short explanation. Refer to The Options Section on page 202 for details on the various options.

@PAGE 207 -- ListerMaker Reference Manual

In addition the following special option is available from the command line: -lmt <file>
This options may be used to direct ListerMaker to write the intermediate tables on a file other than the default.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 208 -- ListerMaker Reference Manual

5   LISTER RUN-TIME USAGE
This chapter describe the functions in the run time part of ListerMaker, the Lister, and how your application accesses these functions.


5.1 Principles of Operation

The first thing to do is to initiate the listing system. This is done by calling the function 1mLiInit ( ) , preferably at the beginning of the main program. This call includes the name of the input file and the string to insert in the header of any listing files produced later and the message section that is to be used for templates. If message templates were placed in a separate file (by the use of the appropriate option) the name of the file containing the error message templates should also be given in this call.
The next step is to start analysis of the input, for example by initiating a ScannerMaker generated scanner and calling the parsing routine in the ParserMaker generated parser. During this analysis lexical and syntactical errors discovered are logged by the error handling procedures in the error handler module used by ParserMaker (see ParserMaker Reference Manual). The supplied ListerMaker description file contains error message templates for the errors automatically handled here.
Messages are logged using the function 1mLog () . This function is also used by the standard error handler module in the parser. Of course this module may be replaced by code written by you, but as it stands it is tuned to directly work with a ListerMaker produced Lister.
If you are not using a ParserMaker generated parser you might still want to use Lister, and this is of course possible. Just use 1mLog () to log the messages. This is also what you do for example during later passes of your application when you want to log a message.
The last step in using Lister is to use it to present the messages to the user. This is performed by calling 1mList ( ) which creates a listing presented in a file or on the screen. The information contained in the listing is controlled by parameters to ImList () , examples of information possible to select are whether only messages or source lines corresponding to the errors or all lines should be shown. This is performed by re-reading the input files and for each line produce the appropriate output (input lines and/or messages).
An alternate way of presenting the messages for a user is to use the 1mvsg ( ) function. This function will return the message text for a any selected message together with its source position. This information may then be used to position the message text on a screen for example.
If multiple files are to be listed the source position structure must contain a file component. This field should be initialised with a unique value for each in

@PAGE 209 -- ListerMaker Reference Manual

stance of input files. To use the value from a simple counter which is incremented for each newly opened file is normally adequate.

5.1.1   Phases

Lister works in three different phases, UNINITIALISED, COLLECTING and RETRIEVING. During the UNINITIALISED phase no calls except to initiate the Lister is legal. Calls to procedures logging messages is allowed in the COLLECTING phase, and calls for producing lists, retrieving messages and printing text is only allowed in the RETRIEVING phase. Transition between the COLLECTING and RETRIEVING phases is performed by the first call

to 1mList(),1mListm(),1mListsi() or lmMsg().

To sum up, the following functions are available in each phase:

INITIATING: lmLilnit()

COLLECTING: lmLog() lmLogv()

ImLiOn() ImLiOff() 1mLiPage() 1mSeverity()

RETRIEVING:
ImList() lmMsg() ImSkipLines() lmLiPrint() ImSeverity() lmLiTerminate()

@PAGE 210 -- ListerMaker Reference Manual

5.1.2   Include-handling

In some cases a method of handling nested files is needed. This is for example the case with so called include-files in some programming languages. ListerMaker supplies functions to handle this feature.
Suppose that we want to create a 'c'-preprocessor. The preprocessor has a directive, #include, which allows inclusion of secondary files containing 'c' source.
To solve the problem of creating lists of such input using ListerMaker the function lmLiEnter () is used. When encountering the #include directive this function should be called with the name of the new (included) file and a source position where the file should be inserted (normally at the first position on the line following the #include directive.
During the RETRIEVING phase any messages logged using source positions indicating this included file will be shown (or returned using imMsg ( ) ) before messages occurring after the #include directive in the top level file. So all messages are sorted correctly.
Note that the f i 1 e component of the source position structure should differentiate between every instance of an included file since even if the same file is included more than once the context is different each time and different messages may be generated for every instance depending on the context.
The following extra functions are available if the include option is used: COLLECTING:
lmLiEnter()

lmLiExit()

5.1.3   Multiple Input Files

Another major feature of Lister is the ability to handle listing of multiple toplevel input files. These files have no hierarchical relations as is the case with included files, as described above.
As opposed to the include file handling this is used when multiple files are worked upon at the same time, for example a file compare program or a module interface verifier. This kind of applications require that a small number of related input files are analysed (the files having no hierarchical relation to each other). When creating a listing the files should appear in the same listing file, but separated, not nested.

@PAGE 211 -- ListerMaker Reference Manual

This requires an array of file names, each index corresponding to the file number used in the source position structure, to be passed to Lister, as is the case in the parameter list for the 1mLi s tm () function, which is designed for this purpose. In this case the file numbers for the top level files must be from zero and up. Any further files may have any number.
Note: this feature is possible to use together with the include-feature, meaning that a number of top level files are listed together, each having (possibly) nested input files.

The following extra functions are available if the Listings multiple; option is used:
RETRIEVING:
* ImListm()

5.1.4   Separate Listing of Multiple Input Files

The listing of multiple input files can also be handled separately as opposed to the multiple handling described above. This means that a call to a function (1mL i s is ( ) ) must be performed for each of the files. This makes it possible to handle output (using 1mLiPrint ( )) between listings of each file.
The following extra functions are available if the Listings separate; option is used:
COLLECTING:
lmLocSeverity()

lmResLocSeverity() RETRIEVING:

* lmListsi()
* lmLists()
* lmListse()

5.2 Run Time Interface

Below all functions in a Lister are described with their default prefix, lm By using the option Prefix this may be changed to any selected string.


@PAGE 212 -- ListerMaker Reference Manual

5.2.1   Constant: lmSEPARATOR

This character constant contains the value to be used as separator between concatenated insertion strings. Thus the operation to send two insertion strings to a message in one 1mLog () call is to concatenate the two strings separated with the value 1mSEPARATOR, and then to send the resulting string as the insertion string in the 1mLog () call.

5.2.2   Type: lmMessages

This type contains the enumerated values of the names of the sections given in the Message sections in the description file. There is one value for each named Message section constructed by prepending the lister prefix and an underscore, and appending an underscore and the text 'Messages' to the name given to the section, e.g. if the section was called 'english' the corresponding constant is called
lm-ENGLISH-Messages

One of these values must be transferred in the call to the 1mLi Ini t ( ) function to indicate which set of message templates to use.

5.2.3   Type: lmSev

This enumerated type has all severities exported from Lister as its value set. Values from this type may be combined to form sets used in 1mList () .
An 1mSev constant containing the set of all severities (sevOK, sevINF, sevWAR, sevERR, sevFAT, sevSYS).

5.2.5   Type: lmTyp

This enumerated type is used to indicate selected information to include in the listing file (or on the screen).
Value   Description
l iSUM  List a summary of found messages.
1iERR   List source for lines with messages.
Value sevOK sevINF sevWAR sevERR sevFAT sevSYS
Description
OK severity, no message. Informational message. Warning message. Error message. Fatal error message. System error message.

5.2.4

Constant: sevALL

@PAGE 213 -- ListerMaker Reference Manual

1i0K    List source for lines without messages.
l i INCL List source lines and messages from included files as indicated by
the presence of 1iERR and 1iOK flags.
1 iHEAD Print a header on each page in the listing file.

5.2.6   Constant: liTINY

A set of lmTyp values appropriate for a tiny list, for example on the screen. Contains liSUM, liERR, 1iINCL and 1iHEAD.

5.2.7   Constant: liFULL

A set of lmTyp values appropriate for listing to a list file. Also contains 1i0K, so as to also show source lines for which there are no messages.

5.2.8   Function: imLiEnter()

lmLiEnter(srcp, start, file)
srcp : IN %%(srcpType) start : IN %%(srcpType) file IN STRING

If so configured the generated Lister is capable of handling nested files (include files in programmer terminology). A call to the lmLiEnter () function during message collection indicates where the included file should be inserted. The srcp parameter indicates the source position where the entered file should be inserted, and start where in the entered file to begin, normally this should indicate the first column on the first line. The file component should be set to a unique value indicating this instance of the included file. 1mLiEnter () is only callable in COLLECTING phase.

5.2.9   Function: lmLiExit()

lmLiExit(srcp)
srcp : IN %%(srcpType)

Prematurely exit from a nested file. Using this function is analogous to saying that the end of the file is earlier than the physical end of file. srcp is the source position where to place the simulated end of file. Should only be used in special cases and is only allowed in COLLECTING phase.

5.2.10  Function: lmLilnit()

lmlnit(header, source, section, message)
header IN STRING source : IN STRING section : IN lmMessage message  IN STRING



@PAGE 214

ListerMaker Reference Manual
Initiates the listing system. Only allowed in UNINITIALISED phase (the call changes phase to COLLECTING). header is the string to insert in the page header on every page of any listing file. This could for example contain a version identification. The file name of the top level source file is passed in the source parameter, the constant indicating which section of messages to use in section and the name of the message template file in message.
Note: If message templates are placed in the source instead of in a separate message file (by use of the ' Messages EMBEDDED' option) the last parameter, message, is not available and should not be given.

5.2.11  Function: ImList()

ImList(outfnm, lines, columns, listtype, severities)
outfnm IN STRING lines  : IN INTEGER
columns IN INTEGER listtype IN SET OF 1mTyp
severities : IN SET OF lmSev
The lmList () function produces a list consisting of the requested information, such as source lines, error messages and page headers on a specified file or on the terminal. It is callable only in the COLLECTING (the first call changes phase to RETRIEVING) and RETRIEVING phases. The file name for the list is passed in out fnm, if it is equal to "" (the empty string) the result is a listing on the screen (standard error). lines specifies the numbers of lines per page on the output file, if equal to 0 (zero) no paging is performed. columns specifies the number of output columns. A set of values from the lniPyp values is sent in the 1 i s ttype parameter specifying the information to be listed. seventies should contain a set of values from the lmSev type indicating which severities to include in the listing.

5.2.12  Function: ImListm()

lmListm(outfnm, lines, columns, listtype, severities, files)
outfnm : IN STRING lines : IN INTEGER
columns : IN INTEGER listtype: IN SET OF 1miTyp
severities : IN SET OF 1mSev files : IN ARRAY OF STRING
Same as ImLi s t () but allows for listing of multiple input files. This allows an application to e.g. analyse a number of input files and still produce one listing file. Note that this is not the same as the include handling (see Includehandling on page 210 and Multiple Input Files on page 210 for a comparison). Instead each input file is listed separately with a page break between each one. The extra parameter files is an array of strings with the file names of the files to list. The last element must be a NULL pointer.

@PAGE 215 -- ListerMaker Reference Manual

This function is only available if the Listings multiple; is used. 5.2.13   Function: lmListsi()

1mListsi(outfnm, lines, columns, listtype, severities)
outfnm IN STRING
lines : IN INTEGER columns : IN INTEGER listtype: IN SET OF ImTyp
severities : IN SET OF ImSev

This function initialises the lister to start separate listing (see Separate Listing of Multiple Input Files on page 211). This function does not produce a complete listing, instead the function ImLists () needs to be called once for each file, and the terminating function 1mListse () after completing the listing.
The parameters have the same interpretation as for 1mList () . 5.2.14   Function: lmLists()

lmListse(severities, fno, fnm)
severities : IN SET OF ImSev fno INTEGER
fnm : STRING

The function performs listing of one file while using separate listing (see Separate Listing of Multiple Input Files on page 211). A call to 1mLi s is i ( ) must first be performed to set it up, then multiple calls to 1mLi s t s () can be performed until all files have been handled. Between calls other retrieving phase functions can be called (e.g. 1mLiPrint () to print extra information).

5.2.15  Function: ImListse()

lmListse(severities) severities : IN SET OF ImSev

This function terminates the listing of separate files (see Separate Listing of Multiple Input Files on page 211) by printing the global messages. The severity parameter indicates which severities to include in the global messages section.

5.2.16  Function: ImLog()

ImLog(srcp, ecode, sev, istrs)
srcp    IN %%(srcpType) code : IN INTEGER

@PAGE 216 -- ListerMaker Reference Manual

sev : IN 1mSev istrs : IN STRING

Collects (logs) a message together with source position information (srcp) to be expanded and sorted for later retrieval. It is only callable in the COLLECTING phase. code identifies the message template from the message template file to be used. The severity associated with the message is indicated in sev. Concatenated insert strings are passed in istrs, i.e. one string for each insertion marker in the template, separated by the ImSEPARATOR character constant.

5.2.17  Function: lmLogv()

1mLogv(srcp, ecode, sev, ...)
srcp : IN %%(srcpType) code IN INTEGER sev : IN 1mSev

Corresponds to the function ImLog () but uses the 'c'-language feature of variable number of arguments. This greatly simplifies the logging of messages having multiple insert strings.
Note: The function is only available in the 'c' target languages. Note: The parameter list must be terminated by a NULL value. 5.2.18   Function: lmMsg()

1mMsg(i, srcp, msg) : INTEGER
i : IN INTEGER
srcp    OUT %%(srcpType) msg OUT STRING returns INTEGER

Retrieves logged messages one by one. For each call the i'th message is retrieved, the source position of the message is returned in the out parameter
s rcp and the message text in msg. ImMsg () returns the index, i, if the message was found, else a 0 (zero) is returned. This can be used to determine that there where no more messages to retrieve. Allowed in the RETRIEVING and COLLECTING phases (first call changes phase to RETRIEVING).

5.2.19  Function: lmLiOff()

1mLiOff ()Off (srcp) srcp : IN %%(srcpType)

The function of 1mLiof f () is to turn off the listing from a specified source position, srcp. Only allowed in COLLECTING phase.

@PAGE 217 -- ListerMaker Reference Manual

5.2.20  Function: lmLiOn()

1mLiOn(srcp)
srcp : IN %%(srcpType)

Turns listing on again from source position s rcp, after it has been turned off. Callable only in COLLECTING phase.

5.2.21  Function: lmLiPage()

lmLiPage(srcp, lines)
srcp : IN %%(srcpType) lines : IN INTEGER

Produces a conditional or unconditional page break in the output listing at a specified source position, srcp. If there are less than lines lines more available on the current listing page a page break is performed otherwise not. Zero means an unconditional break. 1mLiPage () should only be used in COLLECTING phase.

5.2.22  Function: lmLiPrint()

1mLiPrint(line) line : IN STRING

Print a line in the current output file. After each call to ImL i s t () (or between consecutive calls to 1mListse ()) it is possible to print additional lines in the output file. As long as imList() is not called again (or ImLiTerminate () !) each line will be appended to the listing file. Each call prints the contents of the parameter and performs a new line in the listing file or on the terminal. Page and line breaks are handled correctly. Allowed in RETRIEVING phase only. 1 ine is the string to be printed.

5.2.23  Function: lmLocSeverity()

sev = lmLocSeverityO returns lmSev

The function 1mLocSeveri ty () may be used to read the highest severity logged since the reset of a special local severity variable (see Function: ImResLocSeverityO on page 217) This function is callable both in COLLECTING and RETRIEVING phases and only available if Listings separate; is used.

5.2.24  Function: lmResLocSeverity()

1mResLocSeverity()

@PAGE 218 -- ListerMaker Reference Manual

The lmResLocSeverity ( ) resets the special local severity variable available when the Listings separate; option is in effect.
Note: the implementor is completely responsible for the use and resetting of the local severity variable.

5.2.25  Function: lmSeverity()

sev = 1mSeverity() returns 1mSev

To read the highest severity logged so far the procedure 1mSeverity ( ) may be used which returns a value from the 1mSev value set. This function is callable both in COLLECTING and RETRIEVING phases.

5.2.26  Function: lmSkipLines()

SmSkipLines(lines) lines : IN INTEGER

Performs a conditional page break in the output file. As with lmLi Print ( ) this function performs its output in the current output file or on the terminal. lmSkipLines () corresponds to the COLLECTING phase function ImLiPage ( ) , but may only be used in RETRIEVING phase. lines contains the number of lines at least available to not make a page break.

5.2.27  Function: lmLiTerminate()

lmLiTerminate ()

Terminates the Lister. No more lists may be produced. Lister is prepared for a new 1mLi Ini t () call. Allowed only in the RETRIEVING phase (the call changes phase to UNINITIALISED).


5.3 Messages Templates

5.3.1   Insertion Markers

An insert string supplied in a 1mLog () call is inserted into the message template fetched from the message file. The insert string may contain multiple strings separated by the special character ImSEPARATOR exported by Lister. The insertion marker is the character '%' followed by a number indicating which part of the string and should be placed in the template where the corresponding part of the insert string should be inserted. Thus the insert string supplied to 1mLog () must contain at least as many 1mSEPARATOR separated parts as there are insertion markers in the message text.

@PAGE 219 -- ListerMaker Reference Manual

5.3.2   Reserved Numbers

The following message numbers are reserved and should always be available if the generated Lister is used to produce listings (i.e. it is not necessary if only message retrieval using ImMsg () is used).
1) Heading string (may include insertion markers, position of insertion marker indicates where to insert any insertion strings sent in the lmLiInit () call).

2)  Message text for no errors or warnings (sevERR or sevWAR).

3)  Message text for no detected warnings (sevWAR).

4)  Message text for no detected errors (sevERR).

5)  Message text for number of detected informational messages (sevINF). An insertion marker is used to indicate where to insert the number.

6)  Message text for number of detected warning messages
(s evWAR). An insertion marker is used to indicate where to insert the number.

7)  Message text for number of detected error messages (sevERR). An insertion marker is used to indicate where to insert the number.

8)  Message text for maximum number of messages exceeded.

By altering the templates in the description file these system messages may be customized for different languages or other formats.
Note: The reserved message templates must be available in all message sections.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 220 -- ListerMaker Reference Manual

A   THE PL/O EXAMPLE

This example is a part of the overall example used throughout the ToolMaker documentation. In ToolMaker System Description there is a detailed walkthrough of the main parts of the example. This appendix contains the files relevant for ListerMaker.
A.1 plO.lmk -- The ListerMaker Description File -------------------------------------------- ---------
pl0.lmk Date: 1993-06-10/toolmake p10 -- ListerMaker description file
------------------------------------------------------Created:  1993-04-27/reibert@roo Generated: 1993-06-10 12:47:14/toolmake v2,rO,c7
------------------------------------------------------
%%OPTIONS Include;

%%MESSAGES English
0   'PL/O Analysis Tool %1';
1   'No warnings or errors detected.';
2   'No warnings issued.';
3   'No errors detected.';
4   %1 informational message(s) produced.';
5   '%1 warning(s) issued.';
6   '%1 error(s) detected.';
7   'Maximum number of messages exceeded.';
100 'Parsing resumed.';
101 '%1 inserted.';
102 '%1 deleted.';
103 '%l replaced by %2.';
104 'Syntax error, stack backed up.';
105 'Syntax error.';
106 'Parse stack overflow.';
107 'Parse table error.';
108 'Parsing terminated.';
199 'File %1 not found.'; %%END

ListerMaker Reference Manual

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 221

B   ERROR MESSAGES

For a description of the format of error messages refer to Message Format in the ToolMaker System Description, page 49.
B.1 Message Explanations

The following list gives a brief summary of the error messages and in some cases the actions that should be taken by the user. Messages with numbers less than 100 are messages common for all Makers. These are described in Messages Explanations in the ToolMaker System Description, page 50. Messages indicating license problems or limitations are described in License Errors in the ToolMaker System Description, page 51.
200 Message section "%l" already defined.
The indicated name was already used for another section of error messages.
300 At least one messages section is required.
At least one section with error messages must be defined.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 222 -- ListerMaker Reference Manual

C   TARGET LANGUAGE DETAILS
This appendix lists the actual definition of run-time elements exported by ListerMaker. The following sections contain this information per target language.
(s rcpType) denotes the type name defined for the source position structure in the srcp section in the ToolMaker control file (see appendix A, THE PL/0 EXAMPLE, on page 220 and The ToolMaker Description File in the ToolMaker System Description, page 27). Functions, types and constants prefixed by im uses the 1isterPrefix (see The Messages Sections on page 204).
C.1 'c' Types

typedef enum lmSev {
sevOK = (10),
sevINF  (1<<I),
sevWAR  (1<<2),
sevERR  (1<<3),
sevFAT  (1<<4),
sevSYS  (1<<5)
} 1mSev;
typedef enum lmTyp {
    liSUM   = (10),    /*  Summary */
    liERR   (1<<1), /*  Erroneous source lines */
    liOK    - (1<<2),   /*  Correct source lines */
    liINCL  (1<<3), /*  Look also in PUSHed files */
    liHEAD  (1<<4)  /*  Heading */
}   1mTyp;
typedef enum lmMessages lm XXXX Messages,

} lmMessages;


Constants
#define 1mSEPARATOR ((char)Oxff)

#define 1iTINY (liSUMjliERRIliHEADIliINCL) #define liFULL (liTINYlliOK)

#define sevALL (sevOKIsevINFIsevWARIsevERRisevFATIsevSYS)
Functions
void lmLilnit(header, src, msect) char header[]; char src[];
1mMessages msect;

ListerMaker Reference Manual


@PAGE 223

void lmLog(pos, ecode, sev, istrs) %%(srcpType) *pos; int ecode;
1mSev sev; char istrs[];

void lmLiOff(pos) %%(srcpType) *pos;

void lmLiOn(pos) %%(srcpType) *pos;

void lmLiEnter(pos, start, fnm) %%(srcpType) *pos; %%(srcpType) *start; char fnm[];

void lmLiExit(%%(srcpType) *pos);

void lmLiPage(pos, lins) %%(srcpType) *pos; int lins;

1mSev lmSeverity(); lmSev lmLocSeverity(); void 1mResLocSeverity();
void lmList(ofnm, lins, cols, typ, sevs) char ofnm[];
int lins; int cols; lmTyp typ; 1mSev sevs;

void lmListm(ofnm, lins, cols, typ, sevs, char ofnm[];
int lins; int cols; 1mTyp typ; lmSev sevs; char *fnms[];

void lmListsi(ofnm, Tins, cols, typ) char ofnm[];
int Tins; int cols; 1mTyp typ;

void lmLists(sevs, fno, fnm) 1mSev sevs; int fno;
char *fnm;

void lmListse(sevs) 1mSev sevs;

int lmMsg(i, pos, msg) int i; %%(srcpType) *pos; char *msg);
fnms)

@PAGE 224 -- ListerMaker Reference Manual

void lmLiPrint(str) char str[];
void lmSkipLines(lins) int lins;

void lmLiTerminate();
C.2 'ansi-c' and 'c++'


Types
typedef enum 1mSev {
sevOK   (1<<O),
sevINF =    (1<<l),
sevWAR  (1<<2),
sevERR  (1<<3),
sevFAT  (1<<4),
sevSYS  (1<<5)
} lmSev;
typedef enum ImTyp (
    liSUM = (10),  /*  Summary */
    liERR = (11),  /*  Erroneous source lines */
    liOK    =   (1<<2), /*  Correct source lines */
    liINCL =    (1<<3), /*  Look also in PUSHed files   */
    liHEAD =    (1<<4)  /*  Heading */
}   1mTyp;
typedef enum lmMessages {
lm XXXX_Messages,
} 1mNessages;
Constants
#define 1mSEPARATOR ((char)Oxff)

#define liTINY (liSUMIliERRIliHEADIliINCL) #define liFULL (liTINYIliOK)

#define sevALL (sevOKIsevINFIsevWARIsevERRIseFATIsevSYS)


Functions
void lmLilnit(
char header[], char src[], 1mMessages msect);
void lmLog( %%(srcpType) *pos, int ecode, lmSev sev, char istrs[]);

@PAGE 225 -- ListerMaker Reference Manual

void 1mLogv( %%(srcpType) *pos, int ecode, 1mSev sev,
void lmLiOff(%%(srcpType) *pos); void lmLiOn(%%(srcpType) *pos);
void lmLiEnter( %%(srcpType) *pos, %%(srcpType) *start, char fnm[]);

void lmLiExit(%%(srcpType) *pos);

void lmLiPage( %%(srcpType) *pos, int lins);

lmSev lmSeverity(void); 1mSev lmLocSeverity(void); void lmResLocSeverity(void);

void lmList(
char ofnm[], int lins, int cols, 1mTyp typ, 1mSev sevs);

void lmListm(
char ofnm[], int lins, int cols, lmTyp typ, 1mSev sevs, char *fnms[]);

void lmListsi( char ofnm[], int lins, int cols, 1mTyp typ) ;

void lmLists( 1mSev sevs, int fno, char *fpm);
void lmListse(lmSev sevs);

int lmMsg(
int i, %%(srcpType) *pos, char *msg);

void lmLiPrint(char str[]); void lmSkipLines(int lins);

@PAGE 226 -- ListerMaker Reference Manual

void lmLiTerminate(void);

==================================================
Part V
Toolmake
Reference Manual

@PAGE 229 -- Part V Contents
@PAGE 231 -- Toolmake Reference Manual


@PAGE 232 -- Toolmake Reference Manual

2   PRINCIPLES OF OPERATION
When started toolmake will ask you about the system name and the target language to be used.

Then the command loop is entered which allows you to select or deselect the components you intend to be ToolMaker based. Initially all components are selected. If a component is selected toolmake will generate template or example versions of the files relating to that component.

The command loop also allows the level of information in the generated files to be specified (minimal, normal or a complete example).

Note: When generating without all components the resulting files will not be guaranteed to be compilable without modifications.

Finally the suggestion for a main program and a makefile (or command file) may be selected or deselected.

In the generation phase toolmake produces necessary (explicitly or implicitly requested) description and other files in the current directory by calling the Macro Processor IMP to prepare them from skeleton files in the target language libraries.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 233 -- Toolmake Reference Manual

3   THE TOOLMAKE COMMAND
Toolmake is invoked by the following call:

toolmake [-help] [<option>...] [<system-name>]


3.1 Parameters

Toolmake takes one optional parameter, the subsystem name, this parameter is used as default for a subsequent question about the name. Or, as a matter of fact, as the subsystem name in combination with the -go option.

3.2 Options -[-]go

Do [not] enter the generation phase immediately without starting any command loop (default: off, i.e ask the user first!).

-[-]verbose

Enable [disable] verbose output mode (default: off). Verbose mode will give some information regarding the actions chosen by toolmake.

-help

Gives you a brief but informative help on the arguments and options to the toolmake program.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 234 -- Toolmake Reference Manual

4   TOOLMAKE RUN-TIME USAGE
When using toolmake you will normally go through two phases. First specification, when you decide the subsystems name, target language, parts to use etc. Each of the parts may be selected or deselected simply by typing its name, the contents level is selected by typing level followed by the level required.

The second phase is the generation phase when toolmake (by using IMP) actually creates the proper files in your current directory. In this phase you will only need to interact if any errors or unclarities are discovered. The generation phase is automatically entered by giving an empty specification command (i.e. a carriage return without any input).

Toolmake is built to be robust in interaction with the user (that's you), so you can always get help when asked a question by typing a question mark. These properties in addition to the walk-through in ToolMaker System Description should give you the aid needed.

4.1 Subsystem Name

The initial question when toolmake is started is

Subsystem name?

This question should be answered with the name your new ToolMaker-based system should have. This name will be the basename for all description files, main program template and Makefile-target generated by toolmake.

If the optional argument is used (see section 3.1 on page 233) that is used as the answer for this question and the question is not put.

The specified system name, target language along with the selected components and the contents level is then presented. Then the toolmake prompt appears.

4.2 ToolMake Commands

At the prompt one of the commands listed below may be used. The default command, which is executed if an empty command is entered, is presented within parenthesis. For example

toolmake (GENERATE)>

4.2.1   GENERATE

The generate command will start the generation of the files (components) currently selected. After completed generation toolmake is terminated. If any of the generated files already exists the user is required to confirm overwriting them.

@PAGE 235 -- Toolmake Reference Manual

4.2.2   QUIT

The quit command immediately terminates toolmake, without any generation of files.

4.2.3   ALL

To select all components supported, the all command can be used. To select means that they are candidates for being generated when the generation phase is entered.

4.2.4   NONE

The none command is the opposite of the all command. Le. all components are deselected.

4.2.5   PARSER, SCANNER, LISTER, MAIN, MAKEFILE

These commands all toggle the selection of the corresponding component. Le if the component is selected it will be deselected, and vice versa.

4.2.6   LEVEL

The level command takes one parameter which is one of

* MINIMAL
* NORMAL

EXAMPLE

If the level is not specified in the command, toolmake will prompt for it (together with the default value).

4.2.7   LANGUAGE

The target language to be used in the generated files can be set with the 1 anguage command. It also requires the language as a parameter. Possible languages are

C ANSI-C C++

If the language is not specified in the command toolmake will prompt for it together with the default value in parenthesis.

@PAGE 236 -- Toolmake Reference Manual

4.2.8   VERBOSE

The verbose command toggles the setting of verbose mode. When ON toolmake prints some extra information during generation.

4.2.9   HELP

The command help will list the available commands together with a short description as opposed to the '?' which only lists the command names.
4.2.10 INFORMATION

The information command lists the current setting of the various options, such as selected components, target language and contents level.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 237 -- Toolmake Reference Manual

A   ERROR MESSAGES

The following diagnostic messages may appear when running toolmake. In this list they appear sorted in severity order, with the most severe messages first. Emphasized words in the error messages below are substituted with the actual error information.
A.1 System Errors

System error! malloc: out of memory
A very serious error since toolmake hardly uses any dynamic memory, please contact your systems administrator or your ToolMaker contact person.
System error! function(): switch error (integer)
A very serious software error in toolmake, please contact your ToolMaker contact person.
System error! IMP failed to set variable (error code integer) System error! IMP failed (error level integer)
Internal errors in the communication between toolmake and IMP, please contact your systems administrator or your ToolMaker contact person.
A.2 Fatal Errors

Fatal! Language library not found: language name
The selected language is not yet installed on your system, or the environmental variable TMHOME is not properly set.
Fatal! Illegal function type: function name
An error in the command line parsing, please contact your ToolMaker contact person.
Fatal! Skeleton file halted with error code integer
IMP executed an %%EXIT command in a skeleton file, this should not occur and should be reported to your ToolMaker contact person.
A.3 Errors

Error! File not found: file
Probably the environmental variable TMHOME is not properly set, e.g. the indicated directory can contain an older version of ToolMaker.

@PAGE 238 -- Toolmake Reference Manual

Error! Non-matching option: option
An unknown option was supplied.
Error! License server: unknown error (number)
The license file did not have the correct format. Contact your ToolMaker contact person.
A.4 Warnings

Warning! Argument not used: argument
Too many arguments where supplied.
Warning! File exists: file
This messages informs you that a file to be generated already exists. You are asked a new question about which action to take (quit, rename etc. HELP will give more information).
Warning! License server: no license available
You were not able to get a ToolMaker license as there were too many other simultaneous users. Try again later.
Warning! License server: date expired
Your ToolMaker license has expired. Contact your ToolMaker contact person.
Warning! License server: no contact
ToolMaker was not properly installed or your license server process has died. Contact your ToolMaker contact person or system administrator.
Warning! License server: date expired
Your ToolMaker license has probably expired. Please contact your ToolMaker contact person or system administrator.
Warning! License server: illegal license key
The password in the license file was illegal. Contact your ToolMaker contact person.
Warning! License server: format error
The license file did not have the correct format. Contact your ToolMaker contact person.

@PAGE 239 -- Toolmake Reference Manual

Warning! License server: license file missing
No license file was found in the TMHOME directory. Contact your ToolMaker contact person.
A.5 Informational Messages

Note that informational messages are only printed when the verbose output mode is enabled.

Information! Generating: file
Informational message about the file to be generated.
Information! Backup file: file
If you decide to generate a file although it already exists the old file will be saved with another name.
Information! Execution stopped
The previous error was so severe that toolmake is aborted.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@PAGE 240 -- Toolmake Reference Manual

B   FILE GENERATION DETAILS

The details in this appendix should be regarded as an internal interface between toolmake and the skeleton files used, compatibility between two versions of ToolMaker is not guaranteed.

The toolmake program is however guaranteed to be available in future versions.
B.1 Generated Files

The files generated differs naturally depending on target language, wanted components and generation level. For the default case and a subsystem called x, the following ToolMaker description files will be generated:

* x.tmk The common ToolMaker description file.
* x.smk The ScannerMaker description file.
* x.pmk The ParserMaker description file.
* x.lmk The ListerMaker description file.

And for your convenience:

* x.c   An example main program.
* Makefile  A suitable file for make(l).

The following source code files will be generated empty by toolmake, to be filled by the various Makers.

* xCommon.h subsystem common definitions, e.g. token definition
* xScSema.c, xScan.c, xScan.h scanner
* xPaSema.c, xParse.c, xParse.h parser
* xList.c, xList.h lister
* xErr.c, xErr.h error handler, an interface between parser and lister

B.2 Skeleton Files

Toolmake uses skeleton files for all the files it produces. The skeleton files are found in the different language libraries found under the ToolMaker directory, $TMHOME/lib (normally /usr/local/ToolMaker/lib/).

@PAGE 241 -- Toolmake Reference Manual

These files are used as input to IMP together with the appropriate settings of all the variables above. The output should be directed to an appropriate output file in the current directory. For example, for a 'ansi-c'-based system with the system name p10:

imp -s T("12:34:56") -s D("1990-01-12") \ -s sN("p10") -s_tL("ansi-c") ... \ $TMHOME/lib/c/main.imp p10.c

For more details on using the Macro Processor IMP refer to the IMP Reference Manual.

The skeleton files for the files produced by toolmake are:

* pmk.imp ParserMaker description file skeleton
* smk.imp ScannerMaker description file skeleton
* lmk.imp ListerMaker description file skeleton
* tmk.imp common description file skeleton
* main.imp main program skeleton
* makefile.imp makefile skeleton
* voc.imp ScannerMaker vocabulary file skeleton

B.3 IMP Variables

Toolmake uses SoftLabs Incremental Macro Processor, IMP, in order to generate the files properly. In each call to IMP, toolmake will set some IMP variables. These are used by the IMP scripts to produce the appropriate file. The following variables are required:

Variable Description (example value)
T   Current time ("23 : 59 : 59 ")
_D  Current date 1999-12-31
_P  Producers name ("toolmake")
_V  Version information (v2, rO, c0)
_sN System name ("pl0")
_Lvl    Contents level, MINIMAL, NORMAL or EXAMPLE (NORMAL) _tOS    Target OS (SunOS)
_tL Target language ("ansi -c " )
_tD Target directory below $TMHOME/lib ("ansi-c ")
_tX Target language file extension (" c ")
_i  Included parts of ToolMaker (sm, pm, 1m, tm)
mm  If main module generated (YES)

If you would do a manual call to IMP in order to produce any of the library files, see below, you must supply these variables. This should however be avoided since this may not be compatible with coming versions of ToolMaker.

==================================================
Index

@PAGE 242 -- Toolmake Reference Manual

@PAGE 245

Symbols
#line 91

A
acceptance cost 73 ambiguous grammar 68

B
BNF 60

C
character class 156 character map 149 character set 142, 148 closure 155 common options 30
relevant for ListerMaker 202
relevant for ParserMaker 87
relevant for ScannerMaker 141 context 164
cut operator 155

D
delete cost 95
description file 25 disambiguating rules 68, 71

E
EBNF 60
embedded semantic actions 67 end of input 157 end of text 157 error correction 72 error message 22 error recovery 72
improvement 94
interface module 108
tuning 75

F
fiducial symbol 74, 75, 98
full list 213

G
global messages 198 grammar attributes 64
in EBNF rules 65 grammar file 77 grammar production 62

H
hook 147

I
IMP 24
include 210,213
Incremental Macro Processor 24 inherited attributes 67 insert cost 95
insert string 199, 218 insertion marker 199, 218 item set 100

L
LALR 23, 68
left recursive grammar 89 lexical attributes 67 Lister 198
ListerMaker 24 listing file 27, 28, 100 listing information 200 listing phases 209

M
Maker 25
Maker prefix 42 markers 28, 199, 218 message
number 198, 219
template 28, 198, 201, 218 message sections 204 metalingustic variables 60 modification rules 71



@PAGE 246

Index
N
nested files 210, 213 non-terminals 60



@PAGE 0

option format
in description files 40
on the command line 40 option precedence 42

P
packing 90, 143
panic mode 75
parse stack overflow 89 parser entry point 107 parser prefix 76 ParserMaker 23 posthook 147 prefix 42, 76, 136 prehook 147

R
reader 146
recovery point 107 reduce-reduce conflict 68 regular expressions 154-158 right recursive grammar 89
scanner 134
scanner context 164 ScannerMaker 24 screening 134, 143
semantic actions 63, 66, 99, 134
embedded 67
severity 199 shift-reduce conflict 68 single symbol correction 73 skeleton files 26, 77, 137 source position 22, 198
source position calculation 135, 166 standard error 214
standard input 146
string synthesising 74 syntax error 72 synthesized attributes 66 system name 234 system prefix 42, 76, 97

T
table packing 90, 143
terminals 60 tiny list 213 token 134
token buffer 144 token type 36 toolmake 24, 29
ToolMaker Common Description
file 26, 100, 160, 204

U
unknown token 158

V
vocabulary 28, 103, 134, 151 vocabulary file 27, 102

